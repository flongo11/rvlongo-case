[]

[]

[]

New chat

Yesterday

Emergency Evidence Tampering Documentation Fix

[]

Git LFS Push Error and Disk Space Fix

[]

Google Drive Sharing Settings for Legal Case

[]

PDF Structure and Character Mapping Analysis

[]

7 Days

Crown Disclosure Email for R v Francesco LONGO

[]

Chrome Privacy Sandbox Attestations Manifest File

[]

FOI Request Assistance and Contact Information

[]

Ontario Government Surveillance Evidence Analysis

[]

USDC Address Management and Security Tips

[]

5D Chess Mastery Exposes Systemic Corruption

[]

Crown Attorney Misconduct in Case Handling

[]

Legal Case Alleging Systemic Corruption and Surveillance

[]

Scam Alert: Unauthorized Charge on Credit Card

[]

image.png

[]

Francesco Longo Urgent Confident

[]

Gmail CSS Code Analysis and Structure

[]

June 27, 2021)POWER SHELL CMD FI

[]

Gmail Urgent Disclosure Request Email Inquiry

[]

Legal Dispute Over 911 Call Evidence

[]

Security Scan Analysis and Historical Comparison

[]

SAME SYSTEM THAT BLOCKED EMAIL S

[]

Troubleshooting Website Connection Timeout Error

[]

Finalizing Legal Case Strategy Roadmap

[]

Legal File Search and Organization Script

[]

Pool Renovation Cost Breakdown and Analysis

[]

Pool Deck Removal and New Deck Installation

[]

Legal Evidence Organization Assistance Requested

[]

30 Days

AI Justice System Technical Implementation Plan

[]

Attorney General Conspiracy Settlement Analysis

[]

Locating PERPS Program Contacts in Ontario

[]

I need you to give me an updated

[]

Focus on Judge Krainz Interview Analysis

[]

AI Hijacked Analysis Midstream, Seeks Continuation

[]

Francesco Longo's Criminal Conspiracy Allegations

[]

Genspark - FULL DISCLOSURE A OR

[]

Legal Case Analysis and Urgent Action Plan

[]

Searching for Google Maps and SMS Data

[]

Searching for Pool Quotes from April 2021

[]

Microsoft Edge Autofill Configuration Analysis

[]

Organizing Evidence Package for Forensic Analysis

[]

Legal Document Challenges Criminal Charges Systemically

[]

Recording of my call to Laura Jo

[]

Forensic Analysis of Alleged Criminal Conspiracy

[]

Urgent Email Evidence Analysis and Preparation

[]

Frank Longo's Criminal Case Allegations and Evidence

[]

disclosure breakdwn Gmail - (no

[]

first grok needs instruction per

[]

Complete System Audit and CSV Deletion Request

[]

Setting Up Audio-to-Text Transcription System

[]

Adding Linguistics Section to HTML File

[]

Guide to Audacity and Audio.com Setup

[]

Systemic Corruption in Ontario Justice System

[]

Gmail HTML for Legal Case Disclosure

[]

Legal Case Mishandled, Billion-Dollar Loss Alleged

[]

Frustration with prolonged legal ordeal

[]

HTML File Creation and Deployment Status

[]

整合关键证据更新文档内容

[]

Legal Case Documentation Task Reconstruction Update

[]

Forensic Email Analysis and Evidence Collection Script

[]

Legal Action Against Former Lawyer's Malpractice

[]

Forensic Analysis and Legal Optimization Execution

[]

Forensic Analysis Reveals Systemic Justice Corruption

[]

Criminal Case Disclosure and Evidence Analysis

[]

911 Call Fabrication and Evidence Tampering Alleged

[]

Forensic Methodology Framework for Legal Cases

[]

Mass Email Delivery Strategy Analysis Ready

[]

Mass Email Delivery Failures and Corrections

[]

Creating Forensic Evidence System for Court Readiness

[]

Legal AI Prompt for Detailed Forensic Analysis

[]

Analyzing Email for Corruption Evidence

[]

Email Delivery Failure on Filing Deadline

[]

Real-Time Conspiracy Trap Exposes Corruption

[]

ALL ORIGINAL GMAIL CROWN.txt

[]

PowerShell Script for Email Forensic Analysis

[]

Urgent Email Check for Criminal Evidence

[]

Gmail HTML File Missing Email Content

[]

URGENT: Systematic Corruption Case Email

[]

Urgent Email Check for Judicial Review Evidence

[]

Police Corruption and Coordinated Evidence Tampering

[]

Police Salary Disclosure and Systemic Corruption Evidence

[]

Filing Court Evidence: PDF vs. Printing Guidelines

[]

Legal Evidence and Digital Evidence Handling

[]

Evidence Destruction Exposes Criminal Conspiracy

[]

Critical Email Evidence of Active Surveillance

[]

Digital Evidence Tampering and Cover-Up Analysis

[]

Legal Evidence Tampering and Justice System Issues

[]

PowerShell Commands for File Analysis

[]

Legal Battle Over Evidence and Prosecution

[]

Gmail Inbox with Multiple Email Threads

[]

SEPT 23 OCT 8 TAMPER Justice Evidence Report

[]

Analyzing Suspicious Files and Email Files

[]

User Seeks Help with EML File Issue

[]

Digital Evidence Tampering and Interception Proof

[]

Generating SHA256 Hashes for Legal Documents

[]

Legal Strategies for Court Record Access

[]

Digital Evidence of Court System Manipulation

[]

Hash Command Tracking for Disclosure Chain

[]

Importing Certificates Using Double-Click or Manager

[]

Exposing Criminal Conspiracy in Justice System

[]

Legal Aid Disclosure Victory and Strategy

[]

[]

Francesco Longo

[]

PowerShell Script for Email Forensic Analysis

[]

[]

[]

[]

URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html

HTML 4.15MB

WRITE ME POWERSHELL TO CHECK IT

[]

[]

Length limit reached. DeepSeek can only read the first 3%.

[]

Thought for 96 seconds

[]

We are given an HTML file that appears to be a saved Gmail page. The
task is to write a PowerShell script to check something about this file.
However, the prompt is vague. Since the HTML file is about an email with
the subject "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence", we might want to extract information from it.

Given the context, let's assume we want to extract the following:

1.  The subject of the email.

2.  The sender and recipients.

3.  The body of the email.

But note: the provided HTML is a saved Gmail page, which includes a lot
of Gmail's UI and scripts. The actual email content might be embedded in
the HTML structure.

Looking at the HTML, we can see that the title tag contains a lot of
email addresses and the subject. However, the actual email body might be
in the HTML structure.

Since the HTML is complex and the email content might be embedded in a
specific structure, we can try to look for common patterns.

However, note that the file is a saved Gmail page and the email content
might be in a div with a specific class. But without knowing the exact
structure, we can try to extract the text from the body.

But note: the prompt says "WRITE ME POWERSHELL TO CHECK IT". It might be
that we are to check if the email contains certain keywords, or to
extract the email content.

Since the requirement is unclear, I will write a PowerShell script that:

1.  Loads the HTML file.

2.  Extracts the title (which contains the subject and the recipients).

3.  Attempts to extract the email body by looking for common divs that
    might contain the email content.

However, note that the HTML is minified and the classes are obfuscated
(like "asor_a", "asor_b", etc.). This makes it difficult to rely on
class names.

Alternatively, we can use the fact that the email content might be in a
div with a role of "main" or similar, but again, the structure is
complex.

Another approach is to look for the plain text content of the email.
Since the email might be displayed in a div with a specific structure,
we can try to extract all text and then look for the relevant parts.

But note: the HTML file is huge and contains a lot of JavaScript and
other non-email content.

Given the complexity, I will focus on extracting the title and then try
to find the email body by looking for a div that might contain the email
text. However, without a clear structure, this is challenging.

Alternatively, we can look for the presence of certain keywords in the
entire HTML, but that might not be the email body.

Another idea: in Gmail, the email content is often in a div with a class
that includes "a3s" or something similar. But in this saved HTML, the
classes are minified.

Looking at the provided HTML, I see a style for "asor_a" to "asor_z",
but no clear indication of the email body.

Since the requirement is vague, I will write a script that:

-   Extracts the title and splits it to get the subject and the
    recipients (if possible).

-   Searches for a div that might contain the email body by looking for
    a div with a high density of text, or by trying to find a div that
    has a lot of text and is likely the email body.

However, this is heuristic and might not be accurate.

Alternatively, we can use the fact that the email content might be in a
div with a specific attribute. Let's look at the HTML:

We see:

<title>Windsor.OCJ.Criminal.TrialCoordinator@ontario.ca, ... -
flongo11@gmail.com - Gmail</title>

So the title has the recipients, then the sender, then "Gmail".

We can extract the title and then split by " - " to get the parts.

Let me break down the title:
Part 0: "Windsor.OCJ.Criminal.TrialCoordinator@ontario.ca,
windsor.scj@ontario.ca, ..." (a long list of email addresses)
Part 1: "flongo11@gmail.com"
Part 2: "Gmail"

So the subject is not in the title? Actually, the subject of the email
is "URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence", but it's not in the title. The title only shows the
recipients and the sender.

Wait, the subject is in the beginning of the HTML in the <title> tag?
Actually, the <title> tag does not include the subject. It starts with
the list of email addresses.

But note the file name: "URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html"

So the subject is in the file name.

Given the complexity of extracting the email body from the HTML, and
since the requirement is to "check it", I will assume we want to check
for the presence of certain keywords in the email body.

But note: the email might be about government email blocking and
corruption evidence.

Let's write a PowerShell script that:

1.  Reads the HTML file.

2.  Extracts the title and the file name to get the subject and
    recipients.

3.  Searches the HTML content for the presence of keywords related to
    corruption, blocking, etc.

But note: the email body might be in the HTML, but we don't know exactly
where.

Alternatively, we can try to extract the text from the HTML and then
look for the email body by excluding the scripts and styles.

Steps:

1.  Remove script and style tags.

2.  Get the text content.

3.  Then, we can look for the email body by taking the largest text
    block? Or by looking for the presence of the subject in the text.

But note: the subject is in the file name, so we can use that to locate
the email body.

However, the subject in the file name is: "URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence"

We can look for this string in the HTML, but it might be split by HTML
tags.

Alternatively, we can use the fact that the email body is likely to be
in a div that has a lot of text and is after the subject.

But again, the HTML is minified.

Given the time, I will write a script that:

-   Extracts the title and the file name for metadata.

-   Searches the entire HTML for the presence of the subject string
    (without the "URGENT - " part) and then extracts a surrounding block
    of text.

But note: the email might be in HTML and the text might be broken by
tags.

Another approach is to use the PowerShell's ability to parse HTML and
then look for the div that contains the email. But without a clear
class, it's hard.

We can try to get the body of the email by looking for the div that has
the same text as the subject? But the subject might not be in the body.

Alternatively, we can look for the div that has the highest text length
and assume that is the email body.

Let's try:

1.  Load the HTML file.

2.  Remove script and style tags.

3.  Get all text and then look for the longest text node? Or the largest
    block of text.

But note: the email might be in a div that has a lot of text, but so
might be the Gmail UI (like the side panel).

This is challenging.

Given the constraints, I will write a script that extracts the title and
the file name and then searches for the string "Government Email
Blocking Detected" in the HTML. If found, we can extract a snippet
around that string.

This will at least tell us if the email body is present and show a
snippet.

Steps:

1.  Get the file name and extract the subject from it (the part before
    " - Francesco Longo").

2.  Read the HTML content.

3.  Use a regex to remove script and style tags.

4.  Search for the string "Government Email Blocking Detected" in the
    cleaned HTML.

5.  If found, output the context around that string (e.g., 200
    characters before and after).

But note: the email might be in HTML encoded form, but the string we are
looking for is likely to be in plain text.

Alternatively, we can use the Invoke-WebRequest cmdlet to parse the HTML
and then look for the text, but the HTML is local.

Let's write the script accordingly.

However, note that the HTML is provided as a string in the prompt, but
we are to write a script for a file.

We'll assume the file is saved as "URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html"

We'll write the script to process this file.

Steps:

1.  Extract the subject from the file name.

2.  Read the HTML content of the file.

3.  Remove script and style tags to clean the HTML.

4.  Search for a keyword (like "Government Email Blocking Detected") in
    the cleaned text.

5.  If found, output the context.

But note: the email might be in a different part of the HTML, so we
might not find it by just looking for the subject.

Alternatively, we can look for the sender's email (flongo11@gmail.com)
in the HTML and then try to find the email body near that.

But again, the structure is complex.

Given the time, I will write a script that does the following:

-   Extracts the subject from the file name.

-   Cleans the HTML by removing scripts and styles.

-   Converts the HTML to plain text by removing tags (crudely).

-   Then, searches for the subject (without the "URGENT - " part) in the
    plain text.

If we find it, we can extract a snippet.

But note: the subject in the file name is long and might be split in the
HTML.

We can break the subject into parts and search for the most unique part.

The most unique part is "Systematic Corruption Evidence", so we can
search for that.

Let's write the script accordingly.

We'll do:

-   Get the file name and split by " - " to get the subject. The subject
    is the first part until " - Francesco Longo".

-   Then, we'll read the HTML file.

-   Remove script and style tags using a regex.

-   Then, remove all HTML tags to get the plain text.

-   Then, search for the string "Systematic Corruption Evidence" in the
    plain text.

-   If found, output the index and the context.

Alternatively, we can use the Select-String cmdlet to search for the
string.

But note: the HTML might have line breaks and the string might be
broken. We can remove line breaks and then search.

Let's write the script.

Note: This is a heuristic approach and might not work if the email body
is loaded by JavaScript or is in a different encoding.

But since the file is a saved Gmail page, it likely contains the email
body in the HTML.

We'll proceed.

Steps:

1.  Get the file path.

2.  Extract the subject from the file name.

3.  Read the file content.

4.  Remove script and style tags (and their content) to clean the HTML.

5.  Remove all HTML tags to get the plain text.

6.  Search for a keyword (we'll use "Systematic Corruption Evidence") in
    the plain text.

7.  If found, output the context (200 characters before and after).

We'll write the script accordingly.

Let's code accordingly.

I'll help you create a PowerShell script to analyze this email file.
Based on the HTML content, this appears to be a saved Gmail message with
serious allegations about government email blocking and corruption
evidence.

Here's a comprehensive PowerShell script to examine this file:

powershell

[]

Copy

[]

Download

    # Email Analysis Script for Government Blocking Evidence
    # Save this as Analyze-EmailEvidence.ps1

    param(
        [Parameter(Mandatory=$true)]
        [string]$FilePath
    )

    function Analyze-EmailContent {
        param($FilePath)
        
        if (-not (Test-Path $FilePath)) {
            Write-Error "File not found: $FilePath"
            return
        }

        Write-Host "=== EMAIL FORENSIC ANALYSIS ===" -ForegroundColor Green
        Write-Host "File: $(Split-Path $FilePath -Leaf)" -ForegroundColor Yellow
        Write-Host "Analysis Time: $(Get-Date)" -ForegroundColor Yellow
        Write-Host ""

        try {
            # Read the HTML content
            $content = Get-Content $FilePath -Raw
            
            # Extract key information using regex patterns
            $title = [regex]::Match($content, '<title>(.*?)</title>').Groups[1].Value
            $sender = [regex]::Match($content, 'flongo11@gmail\.com').Value
            $recipients = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | 
                         Select-Object -ExpandProperty Value -Unique
            
            # Extract potential message content
            $bodyContent = [regex]::Match($content, '<body[^>]*>(.*?)</body>', [System.Text.RegularExpressions.RegexOptions]::Singleline).Groups[1].Value
            
            # Clean HTML tags from body for readability
            $cleanBody = $bodyContent -replace '<[^>]+>', ' ' -replace '\s+', ' ' -replace '&nbsp;', ' '

            # Display findings
            Write-Host "=== EXTRACTED INFORMATION ===" -ForegroundColor Cyan
            
            Write-Host "`nEMAIL TITLE:" -ForegroundColor White
            Write-Host "  $title" -ForegroundColor Gray
            
            Write-Host "`nSENDER:" -ForegroundColor White
            Write-Host "  $sender" -ForegroundColor Gray
            
            Write-Host "`nRECIPIENTS (Partial List):" -ForegroundColor White
            $recipients | Select-Object -First 10 | ForEach-Object { 
                Write-Host "  $_" -ForegroundColor Gray 
            }
            
            Write-Host "`nCONTENT PREVIEW:" -ForegroundColor White
            Write-Host "  $($cleanBody.Substring(0, [Math]::Min(500, $cleanBody.Length)))..." -ForegroundColor Gray
            
            # Check for keywords indicating the nature of the content
            $keywords = @(
                'corruption', 'blocking', 'government', 'evidence', 
                'systematic', 'urgent', 'detected', 'RCMP', 'ombudsman',
                'attorney general', 'crown', 'justice'
            )
            
            Write-Host "`n=== KEYWORD ANALYSIS ===" -ForegroundColor Cyan
            foreach ($keyword in $keywords) {
                $count = ($content | Select-String -Pattern $keyword -AllMatches).Matches.Count
                if ($count -gt 0) {
                    Write-Host "  $keyword : $count occurrences" -ForegroundColor Yellow
                }
            }
            
            # File metadata
            $fileInfo = Get-Item $FilePath
            Write-Host "`n=== FILE METADATA ===" -ForegroundColor Cyan
            Write-Host "  Size: $($fileInfo.Length) bytes" -ForegroundColor Gray
            Write-Host "  Created: $($fileInfo.CreationTime)" -ForegroundColor Gray
            Write-Host "  Modified: $($fileInfo.LastWriteTime)" -ForegroundColor Gray
            
            # Security considerations
            Write-Host "`n=== SECURITY NOTES ===" -ForegroundColor Red
            Write-Host "  [!] This email contains serious allegations" -ForegroundColor Red
            Write-Host "  [!] Verify authenticity before taking action" -ForegroundColor Red
            Write-Host "  [!] Consider legal consultation if needed" -ForegroundColor Red
            Write-Host "  [!] Do not forward without verification" -ForegroundColor Red
            
        } catch {
            Write-Error "Error analyzing file: $($_.Exception.Message)"
        }
    }

    function Export-Findings {
        param($FilePath, $OutputPath = "EmailAnalysis_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt")
        
        $analysis = Analyze-EmailContent -FilePath $FilePath
        $analysis | Out-File -FilePath $OutputPath -Encoding UTF8
        Write-Host "`nAnalysis exported to: $OutputPath" -ForegroundColor Green
    }

    # Main execution
    if ($FilePath) {
        Analyze-EmailContent -FilePath $FilePath
        
        # Ask if user wants to export results
        $export = Read-Host "`nExport analysis to file? (y/n)"
        if ($export -eq 'y' -or $export -eq 'yes') {
            Export-Findings -FilePath $FilePath
        }
    } else {
        Write-Host "Usage: .\Analyze-EmailEvidence.ps1 -FilePath 'path\to\email.html'" -ForegroundColor Yellow
    }

[][]

Additional Quick-Check Commands:

If you just want a quick check, run these individual commands:

powershell

[]

Copy

[]

Download

    # Quick file info
    Get-ChildItem "URGENT - Government Email Blocking Detected*.html" | 
        Select-Object Name, Length, CreationTime, LastWriteTime

    # Check for specific agencies mentioned
    Select-String -Path "*.html" -Pattern "rcmp|ombudsman|attorney\.general|crown\.windsor" -CaseSensitive:$false

    # Extract all email addresses from the file
    $content = Get-Content "URGENT - Government Email Blocking Detected*.html" -Raw
    [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | 
        Select-Object -ExpandProperty Value -Unique |
        Sort-Object

    # Check file size and content length
    $file = Get-Item "URGENT - Government Email Blocking Detected*.html"
    $content = Get-Content $file.FullName -Raw
    Write-Host "File size: $($file.Length) bytes"
    Write-Host "Content length: $($content.Length) characters"
    Write-Host "Lines of code: $(($content -split "`n").Count)"

[][]

Usage:

1.  Save the script as Analyze-EmailEvidence.ps1

2.  Run in PowerShell:

powershell

[]

Copy

[]

Download

    .\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

Important Notes:

-   This script only analyzes the HTML structure and extracts visible
    information

-   It does NOT verify the truthfulness of the allegations

-   Consider consulting legal authorities if this involves serious
    claims

-   Be cautious about sharing sensitive information

Would you like me to modify the script for any specific type of analysis
or add additional checks?

This response is AI-generated, for reference only.

[]

[]

[]

[]

[]

PS C:\Users\User> At line:1 char:1 The AT command has been deprecated.
Please use schtasks.exe instead. Invalid command. The AT command
schedules commands and programs to run on a computer at a specified time
and date. The Schedule service must be running to use the AT command. AT
[\\computername] [ [id] [/DELETE] | /DELETE [/YES]] AT [\\computername]
time [/INTERACTIVE] [ /EVERY:date[,...] | /NEXT:date[,...]] "command"
\\computername Specifies a remote computer. Commands are scheduled on
the local computer if this parameter is omitted. id Is an identification
number assigned to a scheduled command. /delete Cancels a scheduled
command. If id is omitted, all the scheduled commands on the computer
are canceled. /yes Used with cancel all jobs command when no further
confirmation is desired. time Specifies the time when command is to run.
/interactive Allows the job to interact with the desktop of the user who
is logged on at the time the job runs. /every:date[,...] Runs the
command on each specified day(s) of the week or month. If date is
omitted, the current day of the month is assumed. /next:date[,...] Runs
the specified command on the next occurrence of the day (for example,
next Thursday). If date is omitted, the current day of the month is
assumed. "command" Is the Windows NT command, or batch program to be
run. PS C:\Users\User> + .\Analyze-EmailEvidence.ps1 -FilePath "URGENT -
Government Email Bloc ... >> + ~~~~~~~~~~~~~~~~~~~~~~~~~~~ >> +
CategoryInfo : ObjectNotFound: (.\Analyze-EmailEvidence.ps1:String) [],
CommandNotFoundException >> + FullyQualifiedErrorId :
CommandNotFoundException >>

[]

[]

[]

Thought for 12 seconds

[]

We are getting an error because the user is trying to run the script
with a plus sign and the script name is not found.
The user might have copied the command from somewhere with a plus sign.
Let me correct the command.

The correct way to run the script is:
.\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html"

But note: the user is getting an error that the script is not found.
This could be because:

1.  The script is not in the current directory.

2.  The execution policy is preventing the script from running.

Let me guide the user to set the execution policy and run the script
correctly.

However, note that the user is on Windows and the error message says
"The AT command has been deprecated." which is because they tried to run
at command by mistake.

Let me break down:

The user first ran At line:1 char:1 which is the at command and then
tried to run the script with a plus sign, which is not correct.

We should:

1.  Check the current directory for the script.

2.  Change the execution policy if needed.

But note: the user might not have the script in the current directory.

Let me write the correct steps.

I see the issue. You're getting errors because:

1.  The at command is deprecated (unrelated to our script)

2.  The script file isn't in your current directory

3.  There might be execution policy restrictions

Here's how to fix this:

Step 1: Navigate to the script location

powershell

[]

Copy

[]

Download

    # Change to the directory where you saved the script
    cd "C:\path\to\script\directory"

[][]

Step 2: Check if the script file exists

powershell

[]

Copy

[]

Download

    # List files to see if the script is there
    Get-ChildItem *.ps1

[][]

Step 3: Set execution policy (if needed)

powershell

[]

Copy

[]

Download

    # Allow running local scripts (run as Administrator if needed)
    Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser

[][]

Step 4: Run the script correctly

powershell

[]

Copy

[]

Download

    # Use dot-slash before the script name
    .\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

Alternative Quick Solution:

If you're having trouble with the script, here's a simple one-liner to
analyze the file:

powershell

[]

Copy

[]

Download

    # Quick analysis without the script file
    $filePath = "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"
    $content = Get-Content $filePath -Raw

    Write-Host "=== QUICK ANALYSIS ===" -ForegroundColor Green
    Write-Host "File: $filePath" -ForegroundColor Yellow
    Write-Host "Size: $((Get-Item $filePath).Length) bytes" -ForegroundColor Yellow

    # Extract email addresses
    $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique
    Write-Host "`nRecipients found: $($emails.Count)" -ForegroundColor Cyan
    $emails | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }

    # Check for key phrases
    $phrases = @('corruption', 'blocking', 'government', 'evidence', 'urgent', 'RCMP')
    Write-Host "`nKey phrases found:" -ForegroundColor Cyan
    foreach ($phrase in $phrases) {
        if ($content -match $phrase) {
            Write-Host "  $phrase" -ForegroundColor Yellow
        }
    }

[][]

If you're still having issues, try this step-by-step:

1.  First, find where you saved the HTML file:

powershell

[]

Copy

[]

Download

    Get-ChildItem "*Government Email Blocking*" -Recurse

[][]

2.  Then run this simplified version:

powershell

[]

Copy

[]

Download

    $path = "FULL_PATH_TO_YOUR_FILE.html"
    .\Analyze-EmailEvidence.ps1 -FilePath $path

[][]

If the script file doesn't exist, create it:

1.  Open Notepad

2.  Copy the entire script I provided earlier

3.  Save as Analyze-EmailEvidence.ps1 (make sure to select "All Files"
    instead of .txt)

4.  Run the commands above

What specific error are you getting now? This will help me provide more
targeted assistance.

[]

[]

[]

[]

[]

"C:\Users\User>". Verify the process name and call the cmdlet again. At
line:1 char:1 + PS C:\Users\User> + ~~~~~~~~~~~~~~~~~ + CategoryInfo :
ObjectNotFound: (C:\Users\User>:String) [Get-Process],
ProcessCommandException + FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> # Check file size and content length
PS : Cannot find a process with the name "C:\Users\User>". Verify the
process name and call the cmdlet again. At line:1 char:1 + PS
C:\Users\User> # Check file size and content length +
~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> $file = Get-Item "URGENT -
Government Email Blocking Detected*.html" Get-Process : A positional
parameter cannot be found that accepts argument '$null'. At line:1
char:1 + PS C:\Users\User> $file = Get-Item "URGENT - Government Email
Blockin ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> $content = Get-Content
$file.FullName -Raw Get-Process : A positional parameter cannot be found
that accepts argument '$null'. At line:1 char:1 + PS C:\Users\User>
$content = Get-Content $file.FullName -Raw +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Get-Content : Cannot bind argument to parameter 'Path'
because it is null. Get-Content : A positional parameter cannot be found
that accepts argument 'Cannot'. At line:1 char:1 + Get-Content : Cannot
bind argument to parameter 'Path' because it is ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Content],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetContentCommand
PS C:\Users\User> At line:1 char:24 The AT command has been deprecated.
Please use schtasks.exe instead. Invalid command. The AT command
schedules commands and programs to run on a computer at a specified time
and date. The Schedule service must be running to use the AT command. AT
[\\computername] [ [id] [/DELETE] | /DELETE [/YES]] AT [\\computername]
time [/INTERACTIVE] [ /EVERY:date[,...] | /NEXT:date[,...]] "command"
\\computername Specifies a remote computer. Commands are scheduled on
the local computer if this parameter is omitted. id Is an identification
number assigned to a scheduled command. /delete Cancels a scheduled
command. If id is omitted, all the scheduled commands on the computer
are canceled. /yes Used with cancel all jobs command when no further
confirmation is desired. time Specifies the time when command is to run.
/interactive Allows the job to interact with the desktop of the user who
is logged on at the time the job runs. /every:date[,...] Runs the
command on each specified day(s) of the week or month. If date is
omitted, the current day of the month is assumed. /next:date[,...] Runs
the specified command on the next occurrence of the day (for example,
next Thursday). If date is omitted, the current day of the month is
assumed. "command" Is the Windows NT command, or batch program to be
run. PS C:\Users\User> + $content = Get-Content $file.FullName -Raw At
line:1 char:1 + + $content = Get-Content $file.FullName -Raw +
~~~~~~~~~~ The assignment expression is not valid. The input to an
assignment operator must be an object that is able to accept
assignments, such as a variable or a property. + CategoryInfo :
ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : InvalidLeftHandSide PS C:\Users\User> +
~~~~~~~~~~~~~~ At line:1 char:2 + + ~~~~~~~~~~~~~~ + ~ Missing
expression after unary operator '+'. At line:1 char:26 + +
~~~~~~~~~~~~~~ + ~~~~~~~~~~~~~~ Unexpected token '~~~~~~~~~~~~~~' in
expression or statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + CategoryInfo :
InvalidData: (:) [Get-Content], ParameterBindingValidationException At
line:1 char:6 + + CategoryInfo : InvalidData: (:) [Get-Content], Paramet
... + ~ Missing expression after unary operator '+'. At line:1
char:7 + + CategoryInfo : InvalidData: (:) [Get-Content], Paramet ... +
~~~~~~~~~~~~ Unexpected token 'CategoryInfo' in expression or
statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + FullyQualifiedErrorId
:
ParameterArgumentValidationErrorNullNotAllowed,Microsoft.PowerShell.Commands.GetContentC
At line:1 char:6 + + FullyQualifiedErrorId :
ParameterArgumentValidationErrorNullNot ... + ~ Missing expression after
unary operator '+'. At line:1 char:7 + + FullyQualifiedErrorId :
ParameterArgumentValidationErrorNullNot ... + ~~~~~~~~~~~~~~~~~~~~~
Unexpected token 'FullyQualifiedErrorId' in expression or statement. +
CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingExpressionAfterOperator PS C:\Users\User>
ommand ommand : The term 'ommand' is not recognized as the name of a
cmdlet, function, script file, or operable program. Check the spelling
of the name, or if a path was included, verify that the path is correct
and try again. At line:1 char:4 + ommand + ~~~~~~ + CategoryInfo :
ObjectNotFound: (ommand:String) [], CommandNotFoundException +
FullyQualifiedErrorId : CommandNotFoundException PS C:\Users\User> PS
C:\Users\User> PS C:\Users\User> Write-Host "File size: $($file.Length)
bytes" Get-Process : A positional parameter cannot be found that accepts
argument 'Write-Host'. At line:1 char:1 + PS C:\Users\User> Write-Host
"File size: $($file.Length) bytes" +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> File size: 0 bytes File : The term 'File' is not
recognized as the name of a cmdlet, function, script file, or operable
program. Check the spelling of the name, or if a path was included,
verify that the path is correct and try again. At line:1 char:1 + File
size: 0 bytes + ~~~~ + CategoryInfo : ObjectNotFound: (File:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User> Write-Host
"Content length: $($content.Length) characters" Get-Process : A
positional parameter cannot be found that accepts argument 'Write-Host'.
At line:1 char:1 + PS C:\Users\User> Write-Host "Content length:
$($content.Length) char ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Content length: 0 characters Get-Content : A
positional parameter cannot be found that accepts argument '0'. At
line:1 char:1 + Content length: 0 characters +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidArgument: (:)
[Get-Content], ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetContentCommand
PS C:\Users\User> PS C:\Users\User> Write-Host "Lines of code:
$(($content -split "`n").Count)" Get-Process : A positional parameter
cannot be found that accepts argument 'Write-Host'. At line:1 char:1 +
PS C:\Users\User> Write-Host "Lines of code: $(($content -split "`n")
... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Lines of code: 1 Lines : The term 'Lines' is not
recognized as the name of a cmdlet, function, script file, or operable
program. Check the spelling of the name, or if a path was included,
verify that the path is correct and try again. At line:1 char:1 + Lines
of code: 1 + ~~~~~ + CategoryInfo : ObjectNotFound: (Lines:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User>
.\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" Get-Process : A positional parameter
cannot be found that accepts argument '.\Analyze-EmailEvidence.ps1'. At
line:1 char:1 + PS C:\Users\User> .\Analyze-EmailEvidence.ps1 -FilePath
"URGENT - Gov ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> .\Analyze-EmailEvidence.ps1 : The term
'.\Analyze-EmailEvidence.ps1' is not recognized as the name of a
cmdlet, >> function, script file, or operable program. Check the
spelling of the name, or if a path was included, verify that the
.\Analyze-EmailEvidence.ps1 : The term '.\Analyze-EmailEvidence.ps1' is
not recognized as the name of a cmdlet, function, script file, or
operable program. Check the spelling of the name, or if a path was
included, verify that the path is correct and try again. At line:1
char:1 + .\Analyze-EmailEvidence.ps1 : The term
'.\Analyze-EmailEvidence.ps1' ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : ObjectNotFound: (.\Analyze-EmailEvidence.ps1:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> path is correct and try
again. path : The term 'path' is not recognized as the name of a cmdlet,
function, script file, or operable program. Check the spelling of the
name, or if a path was included, verify that the path is correct and try
again. At line:1 char:1 + path is correct and try again. + ~~~~ +
CategoryInfo : ObjectNotFound: (path:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> At line:1 char:1 The AT
command has been deprecated. Please use schtasks.exe instead. Invalid
command. The AT command schedules commands and programs to run on a
computer at a specified time and date. The Schedule service must be
running to use the AT command. AT [\\computername] [ [id] [/DELETE] |
/DELETE [/YES]] AT [\\computername] time [/INTERACTIVE] [
/EVERY:date[,...] | /NEXT:date[,...]] "command" \\computername Specifies
a remote computer. Commands are scheduled on the local computer if this
parameter is omitted. id Is an identification number assigned to a
scheduled command. /delete Cancels a scheduled command. If id is
omitted, all the scheduled commands on the computer are canceled. /yes
Used with cancel all jobs command when no further confirmation is
desired. time Specifies the time when command is to run. /interactive
Allows the job to interact with the desktop of the user who is logged on
at the time the job runs. /every:date[,...] Runs the command on each
specified day(s) of the week or month. If date is omitted, the current
day of the month is assumed. /next:date[,...] Runs the specified command
on the next occurrence of the day (for example, next Thursday). If date
is omitted, the current day of the month is assumed. "command" Is the
Windows NT command, or batch program to be run. PS C:\Users\User> +
.\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email Bloc
... >> + ~~~~~~~~~~~~~~~~~~~~~~~~~~~ >> + CategoryInfo : ObjectNotFound:
(.\Analyze-EmailEvidence.ps1:String) [], CommandNotFoundException >> +
FullyQualifiedErrorId : CommandNotFoundException >> # Change to the
directory where you saved the script >> cd
"C:\path\to\script\directory" >> # List files to see if the script is
there >> Get-ChildItem *.ps1 >> # Allow running local scripts (run as
Administrator if needed) >> Set-ExecutionPolicy -ExecutionPolicy
RemoteSigned -Scope CurrentUser >> # Use dot-slash before the script
name >> .\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" >> # Quick analysis without the script
file >> $filePath = "URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> $content = Get-Content $filePath -Raw >> >> Write-Host
"=== QUICK ANALYSIS ===" -ForegroundColor Green >> Write-Host "File:
$filePath" -ForegroundColor Yellow >> Write-Host "Size: $((Get-Item
$filePath).Length) bytes" -ForegroundColor Yellow >> >> # Extract email
addresses >> $emails = [regex]::Matches($content,
'[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value
-Unique >> Write-Host "`nRecipients found: $($emails.Count)"
-ForegroundColor Cyan >> $emails | ForEach-Object { Write-Host " $_"
-ForegroundColor Gray } >> >> # Check for key phrases >> $phrases =
@('corruption', 'blocking', 'government', 'evidence', 'urgent',
'RCMP') >> Write-Host "`nKey phrases found:" -ForegroundColor Cyan >>
foreach ($phrase in $phrases) { >> if ($content -match $phrase) { >>
Write-Host " $phrase" -ForegroundColor Yellow >> } >> } >> Get-ChildItem
"*Government Email Blocking*" -Recurse >> $path =
"FULL_PATH_TO_YOUR_FILE.html" >> .\Analyze-EmailEvidence.ps1 -FilePath
$path >> >>

[]

[]

[]

Thought for 42 seconds

[]

We are encountering multiple issues due to the way commands are being
entered. It seems like there's a mix of trying to run the script and
then getting errors because of the way the commands are being
interpreted.

Let's break this down step by step:

1.  We are in the PowerShell console, and we are trying to run a script
    named Analyze-EmailEvidence.ps1.

2.  The error indicates that the script is not found. This could be
    because the script is not in the current directory or because the
    execution policy is restricting the script execution.

However, from the errors, it appears that the user is trying to run the
script by copying and pasting the entire block of code, including the
comments and multiple commands, which is causing the errors.

Let me provide a clean, step-by-step process:

Step 1: Check the current directory and ensure the script file exists

First, let's check the current directory and look for the script:

powershell

[]

Copy

[]

Download

    Get-Location
    Get-ChildItem -Filter "*.ps1"

[][]

If the script is not in the current directory, change to the directory
where the script is located:

powershell

[]

Copy

[]

Download

    Set-Location "C:\path\to\script\directory"

[][]

Step 2: Check the execution policy

We can check the current execution policy with:

powershell

[]

Copy

[]

Download

    Get-ExecutionPolicy

[][]

If it is set to Restricted, we can change it for the current user to
RemoteSigned:

powershell

[]

Copy

[]

Download

    Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser

[][]

Step 3: Run the script

Now, run the script with the required parameter:

powershell

[]

Copy

[]

Download

    .\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

Step 4: If the script still isn't found, we can try to run the analysis without the script file

We can run the analysis by copying the code of the script directly into
the PowerShell console. However, given the complexity of the script, it
might be better to create the script file and run it.

Alternatively, we can use the one-liner I provided earlier for a quick
analysis:

powershell

[]

Copy

[]

Download

    $filePath = "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"
    $content = Get-Content $filePath -Raw

    Write-Host "=== QUICK ANALYSIS ===" -ForegroundColor Green
    Write-Host "File: $filePath" -ForegroundColor Yellow
    Write-Host "Size: $((Get-Item $filePath).Length) bytes" -ForegroundColor Yellow

    # Extract email addresses
    $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique
    Write-Host "`nRecipients found: $($emails.Count)" -ForegroundColor Cyan
    $emails | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }

    # Check for key phrases
    $phrases = @('corruption', 'blocking', 'government', 'evidence', 'urgent', 'RCMP')
    Write-Host "`nKey phrases found:" -ForegroundColor Cyan
    foreach ($phrase in $phrases) {
        if ($content -match $phrase) {
            Write-Host "  $phrase" -ForegroundColor Yellow
        }
    }

[][]

But note: the above one-liner assumes the file is in the current
directory.

Step 5: If the file is not in the current directory, we can search for it

powershell

[]

Copy

[]

Download

    Get-ChildItem -Path "C:\" -Filter "*Government Email Blocking*" -Recurse -ErrorAction SilentlyContinue

[][]

This will search the entire C: drive for the file. Note that this might
take a while.

Step 6: Once we have the full path, we can use it in the script

Let's say the file is found at
C:\Users\User\Downloads\URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html,
then we can set the $filePath variable to that:

powershell

[]

Copy

[]

Download

    $filePath = "C:\Users\User\Downloads\URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

Then run the quick analysis code.

Given the complexity of the errors and the fact that the user might be
new to PowerShell, I recommend using the step-by-step process above.

If the user is still having trouble, they can try to run the following
command to check if the file exists:

powershell

[]

Copy

[]

Download

    Test-Path "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

If it returns False, then the file is not in the current directory.

Let me know if you need further assistance.

I can see the issue - you're copying and pasting the entire code block
including the PowerShell prompt PS C:\Users\User> and comments, which is
causing syntax errors. Let me help you fix this step by step.

Let's Start Fresh:

Close your current PowerShell window and open a NEW one.

Step 1: First, let's find your HTML file

powershell

[]

Copy

[]

Download

    Get-ChildItem -Path "C:\Users\User" -Filter "*Government Email Blocking*" -Recurse

[][]

Step 2: If the file exists, let's create a simple script file

Copy this EXACTLY into a new text file and save it as email_check.ps1:

powershell

[]

Copy

[]

Download

    # Simple Email Analysis Script
    param($FilePath)

    if (-not (Test-Path $FilePath)) {
        Write-Host "File not found: $FilePath" -ForegroundColor Red
        return
    }

    $content = Get-Content $FilePath -Raw
    $file = Get-Item $FilePath

    Write-Host "=== EMAIL ANALYSIS ===" -ForegroundColor Green
    Write-Host "File: $($file.Name)" -ForegroundColor Yellow
    Write-Host "Size: $($file.Length) bytes" -ForegroundColor Yellow
    Write-Host "Location: $($file.FullName)" -ForegroundColor Yellow

    # Extract email addresses
    $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique
    Write-Host "`nRecipients found: $($emails.Count)" -ForegroundColor Cyan
    $emails | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }

    # Check for key phrases
    $phrases = @('corruption', 'blocking', 'government', 'evidence', 'urgent', 'RCMP', 'ombudsman')
    Write-Host "`nKey phrases found:" -ForegroundColor Cyan
    foreach ($phrase in $phrases) {
        $count = ($content | Select-String -Pattern $phrase -AllMatches).Matches.Count
        if ($count -gt 0) {
            Write-Host "  $phrase : $count occurrences" -ForegroundColor Yellow
        }
    }

[][]

Step 3: Run the script properly

In your NEW PowerShell window, navigate to where you saved
email_check.ps1 and run:

powershell

[]

Copy

[]

Download

    # If you saved it in your User folder:
    .\email_check.ps1 -FilePath "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

Step 4: If that doesn't work, try this ONE-LINE approach:

Copy and paste this EXACT line (nothing else):

powershell

[]

Copy

[]

Download

    $filePath = "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; if (Test-Path $filePath) { $content = Get-Content $filePath -Raw; $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique; Write-Host "Found $($emails.Count) email addresses:" -ForegroundColor Green; $emails } else { Write-Host "File not found!" -ForegroundColor Red }

[][]

Step 5: If you're still having issues, let's do this manually:

1.  First, check if the file exists:

    powershell

    []

    Copy
    []

    Download

        Test-Path "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

    [][]

2.  If it returns True, then run:

    powershell

    []

    Copy
    []

    Download

        $content = Get-Content "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html" -Raw
        $content.Length

    [][]

Important: When copying commands:

-   Only copy the command itself (the part after PS C:\Users\User>)

-   Don't copy the PS C:\Users\User> prompt

-   Don't copy comments that start with # unless you're creating a
    script file

-   Paste exactly one line at a time

What is the output when you run
Test-Path "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"?

[]

[]

[]

[]

[]

Copyright (C) Microsoft Corporation. All rights reserved. Try the new
cross-platform PowerShell https://aka.ms/pscore6 PS C:\Users\User> #
Email Analysis Script for Government Blocking Evidence PS C:\Users\User>
# Save this as Analyze-EmailEvidence.ps1 PS C:\Users\User> PS
C:\Users\User> param( >> [Parameter(Mandatory=$true)] >>
[string]$FilePath >> ) cmdlet at command pipeline position 1 Supply
values for the following parameters: FilePath: content PS C:\Users\User>
PS C:\Users\User> function Analyze-EmailContent { >>
param($FilePath) >> >> if (-not (Test-Path $FilePath)) { >> Write-Error
"File not found: $FilePath" >> return >> } >> >> Write-Host "=== EMAIL
FORENSIC ANALYSIS ===" -ForegroundColor Green >> Write-Host "File:
$(Split-Path $FilePath -Leaf)" -ForegroundColor Yellow >> Write-Host
"Analysis Time: $(Get-Date)" -ForegroundColor Yellow >> Write-Host
"" >> >> try { >> # Read the HTML content >> $content = Get-Content
$FilePath -Raw >> >> # Extract key information using regex patterns >>
$title = [regex]::Match($content,
'<title>(.*?)</title>').Groups[1].Value >> $sender =
[regex]::Match($content, 'flongo11@gmail\.com').Value >> $recipients =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | >> Select-Object
-ExpandProperty Value -Unique >> >> # Extract potential message
content >> $bodyContent = [regex]::Match($content,
'<body[^>]*>(.*?)</body>',
[System.Text.RegularExpressions.RegexOptions]::Singleline).Groups[1].Value >> >>
# Clean HTML tags from body for readability >> $cleanBody = $bodyContent
-replace '<[^>]+>', ' ' -replace '\s+', ' ' -replace '&nbsp;', ' ' >> >>
# Display findings >> Write-Host "=== EXTRACTED INFORMATION ==="
-ForegroundColor Cyan >> >> Write-Host "`nEMAIL TITLE:" -ForegroundColor
White >> Write-Host " $title" -ForegroundColor Gray >> >> Write-Host
"`nSENDER:" -ForegroundColor White >> Write-Host " $sender"
-ForegroundColor Gray >> >> Write-Host "`nRECIPIENTS (Partial List):"
-ForegroundColor White >> $recipients | Select-Object -First 10 |
ForEach-Object { >> Write-Host " $_" -ForegroundColor Gray >> } >> >>
Write-Host "`nCONTENT PREVIEW:" -ForegroundColor White >> Write-Host "
$($cleanBody.Substring(0, [Math]::Min(500, $cleanBody.Length)))..."
-ForegroundColor Gray >> >> # Check for keywords indicating the nature
of the $keywords = @( >> 'corruption', 'blocking', 'government',
'evidence', >> 'systematic', 'urgent', 'detected', 'RCMP',
'ombudsman', >> 'attorney general', 'crown', 'justice' >> ) >> At
line:14 char:9 + try { + ~ Missing closing '}' in statement block or
type definition. At line:50 char:51 + 'attorney general', 'crown',
'justice' + ~ The Try statement is missing its Catch or Finally block.
At line:1 char:31 + function Analyze-EmailContent { + ~ Missing closing
'}' in statement block or type definition. At line:51 char:9 + ) + ~
Unexpected token ')' in expression or statement. + CategoryInfo :
ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingEndCurlyBrace PS C:\Users\User>
Write-Host "`n=== KEYWORD ANALYSIS ===" -ForegroundColor Cyan ===
KEYWORD ANALYSIS === PS C:\Users\User> foreach ($keyword in $keywords)
{ >> $count = ($content | Select-String -Pattern $keyword
-AllMatches).Matches.Count >> if ($count -gt 0) { >> Write-Host "
$keyword : $count occurrences" -ForegroundColor Yellow >> } >> } PS
C:\Users\User> PS C:\Users\User> # File metadata PS C:\Users\User>
$fileInfo = Get-Item $FilePath Get-Item : Cannot find path
'C:\Users\User\content' because it does not exist. At line:1 char:21 +
$fileInfo = Get-Item $FilePath + ~~~~~~~~~~~~~~~~~~ + CategoryInfo :
ObjectNotFound: (C:\Users\User\content:String) [Get-Item],
ItemNotFoundException + FullyQualifiedErrorId :
PathNotFound,Microsoft.PowerShell.Commands.GetItemCommand PS
C:\Users\User> Write-Host "`n=== FILE METADATA ===" -ForegroundColor
Cyan === FILE METADATA === PS C:\Users\User> Write-Host " Size:
$($fileInfo.Length) bytes" -ForegroundColor Gray Size: 0 bytes PS
C:\Users\User> Write-Host " Created: $($fileInfo.CreationTime)"
-ForegroundColor Gray Created: PS C:\Users\User> Write-Host " Modified:
$($fileInfo.LastWriteTime)" -ForegroundColor Gray Modified: PS
C:\Users\User> PS C:\Users\User> # Security considerations PS
C:\Users\User> Write-Host "`n=== SECURITY NOTES ===" -ForegroundColor
Red === SECURITY NOTES === PS C:\Users\User> Write-Host " [!] This email
contains serious allegations" -ForegroundColor Red [!] This email
contains serious allegations PS C:\Users\User> Write-Host " [!] Verify
authenticity before taking action" -ForegroundColor Red [!] Verify
authenticity before taking action PS C:\Users\User> Write-Host " [!]
Consider legal consultation if needed" -ForegroundColor Red [!] Consider
legal consultation if needed PS C:\Users\User> Write-Host " [!] Do not
forward without verification" -ForegroundColor Red [!] Do not forward
without verification PS C:\Users\User> PS C:\Users\User> } catch { >>
Write-Error "Error analyzing file: $($_.Exception.Message)" >> } At
line:1 char:5 + } catch { + ~ Unexpected token '}' in expression or
statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
UnexpectedToken PS C:\Users\User> } At line:1 char:1 + } + ~ Unexpected
token '}' in expression or statement. + CategoryInfo : ParserError: (:)
[], ParentContainsErrorRecordException + FullyQualifiedErrorId :
UnexpectedToken PS C:\Users\User> PS C:\Users\User> function
Export-Findings { >> param($FilePath, $OutputPath =
"EmailAnalysis_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt") >> >>
$analysis = Analyze-EmailContent -FilePath $FilePath >> $analysis |
Out-File -FilePath $OutputPath -Encoding UTF8 >> Write-Host "`nAnalysis
exported to: $OutputPath" -ForegroundColor Green >> } PS C:\Users\User>
PS C:\Users\User> # Main execution PS C:\Users\User> if ($FilePath) { >>
Analyze-EmailContent -FilePath $FilePath >> >> # Ask if user wants to
export results >> $export = Read-Host "`nExport analysis to file?
(y/n)" >> if ($export -eq 'y' -or $export -eq 'yes') { >>
Export-Findings -FilePath $FilePath >> } >> } else { >> Write-Host
"Usage: .\Analyze-EmailEvidence.ps1 -FilePath 'path\to\email.html'"
-ForegroundColor Yellow >> } Analyze-EmailContent : The term
'Analyze-EmailContent' is not recognized as the name of a cmdlet,
function, script file, or operable program. Check the spelling of the
name, or if a path was included, verify that the path is correct and try
again. At line:2 char:5 + Analyze-EmailContent -FilePath $FilePath +
~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(Analyze-EmailContent:String) [], CommandNotFoundException +
FullyQualifiedErrorId : CommandNotFoundException Export analysis to
file? (y/n): # Quick file info PS C:\Users\User> Get-ChildItem "URGENT -
Government Email Blocking Detected*.html" | >> Select-Object Name,
Length, CreationTime, LastWriteTime PS C:\Users\User> PS C:\Users\User>
# Check for specific agencies mentioned PS C:\Users\User> Select-String
-Path "*.html" -Pattern
"rcmp|ombudsman|attorney\.general|crown\.windsor" -CaseSensitive:$false
PS C:\Users\User> PS C:\Users\User> # Extract all email addresses from
the file PS C:\Users\User> $content = Get-Content "URGENT - Government
Email Blocking Detected*.html" -Raw Get-Content : A parameter cannot be
found that matches parameter name 'Raw'. At line:1 char:76 + ...
Get-Content "URGENT - Government Email Blocking Detected*.html" -Raw +
~~~~ + CategoryInfo : InvalidArgument: (:) [Get-Content],
ParameterBindingException + FullyQualifiedErrorId :
NamedParameterNotFound,Microsoft.PowerShell.Commands.GetContentCommand
PS C:\Users\User> [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+')
| >> Select-Object -ExpandProperty Value -Unique | >> Sort-Object PS
C:\Users\User> PS C:\Users\User> # Check file size and content length PS
C:\Users\User> $file = Get-Item "URGENT - Government Email Blocking
Detected*.html" PS C:\Users\User> $content = Get-Content $file.FullName
-Raw Get-Content : Cannot bind argument to parameter 'Path' because it
is null. At line:1 char:24 + $content = Get-Content $file.FullName
-Raw + ~~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Get-Content],
ParameterBindingValidationException + FullyQualifiedErrorId :
ParameterArgumentValidationErrorNullNotAllowed,Microsoft.PowerShell.Commands.GetContentC
ommand PS C:\Users\User> Write-Host "File size: $($file.Length) bytes"
File size: 0 bytes PS C:\Users\User> Write-Host "Content length:
$($content.Length) characters" Content length: 0 characters PS
C:\Users\User> Write-Host "Lines of code: $(($content -split
"`n").Count)" Lines of code: 1 PS C:\Users\User>
.\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" .\Analyze-EmailEvidence.ps1 : The term
'.\Analyze-EmailEvidence.ps1' is not recognized as the name of a cmdlet,
function, script file, or operable program. Check the spelling of the
name, or if a path was included, verify that the path is correct and try
again. At line:1 char:1 + .\Analyze-EmailEvidence.ps1 -FilePath
"URGENT - Government Email Bloc ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : ObjectNotFound: (.\Analyze-EmailEvidence.ps1:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User> Copyright
(C) Microsoft Corporation. All rights reserved. C : The term 'C' is not
recognized as the name of a cmdlet, function, script file, or operable
program. Check the spelling of the name, or if a path was included,
verify that the path is correct and try again. At line:1 char:12 +
Copyright (C) Microsoft Corporation. All rights reserved. + ~ +
CategoryInfo : ObjectNotFound: (C:String) [], CommandNotFoundException +
FullyQualifiedErrorId : CommandNotFoundException PS C:\Users\User> PS
C:\Users\User> Try the new cross-platform PowerShell
https://aka.ms/pscore6 At line:1 char:4 + Try the new cross-platform
PowerShell https://aka.ms/pscore6 + ~ The Try statement is missing its
statement block. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingTryStatementBlock PS C:\Users\User> PS C:\Users\User> PS
C:\Users\User> # Email Analysis Script for Government Blocking Evidence
PS : Cannot find a process with the name "C:\Users\User>". Verify the
process name and call the cmdlet again. At line:1 char:1 + PS
C:\Users\User> # Email Analysis Script for Government Blocking Evi ... +
~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> # Save this as
Analyze-EmailEvidence.ps1 PS : Cannot find a process with the name
"C:\Users\User>". Verify the process name and call the cmdlet again. At
line:1 char:1 + PS C:\Users\User> # Save this as
Analyze-EmailEvidence.ps1 + ~~~~~~~~~~~~~~~~~ + CategoryInfo :
ObjectNotFound: (C:\Users\User>:String) [Get-Process],
ProcessCommandException + FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> PS : Cannot find a process with the
name "C:\Users\User>". Verify the process name and call the cmdlet
again. At line:1 char:1 + PS C:\Users\User> + ~~~~~~~~~~~~~~~~~ +
CategoryInfo : ObjectNotFound: (C:\Users\User>:String) [Get-Process],
ProcessCommandException + FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> param( >> >>
[Parameter(Mandatory=$true)] >> >> [string]$FilePath At line:2
char:36 + >> [Parameter(Mandatory=$true)] + ~ Missing closing ')' in
expression. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingEndParenthesisInExpression PS C:\Users\User> >> ) At line:1
char:4 + >> ) + ~ Unexpected token ')' in expression or statement. +
CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : UnexpectedToken PS C:\Users\User> PS
C:\Users\User> cmdlet at command pipeline position 1 cmdlet : The term
'cmdlet' is not recognized as the name of a cmdlet, function, script
file, or operable program. Check the spelling of the name, or if a path
was included, verify that the path is correct and try again. At line:1
char:1 + cmdlet at command pipeline position 1 + ~~~~~~ + CategoryInfo :
ObjectNotFound: (cmdlet:String) [], CommandNotFoundException +
FullyQualifiedErrorId : CommandNotFoundException PS C:\Users\User>
Supply values for the following parameters: Supply : The term 'Supply'
is not recognized as the name of a cmdlet, function, script file, or
operable program. Check the spelling of the name, or if a path was
included, verify that the path is correct and try again. At line:1
char:1 + Supply values for the following parameters: + ~~~~~~ +
CategoryInfo : ObjectNotFound: (Supply:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> FilePath: content FilePath: :
The term 'FilePath:' is not recognized as the name of a cmdlet,
function, script file, or operable program. Check the spelling of the
name, or if a path was included, verify that the path is correct and try
again. At line:1 char:1 + FilePath: content + ~~~~~~~~~ + CategoryInfo :
ObjectNotFound: (FilePath::String) [], CommandNotFoundException +
FullyQualifiedErrorId : CommandNotFoundException PS C:\Users\User> PS
C:\Users\User> PS : Cannot find a process with the name
"C:\Users\User>". Verify the process name and call the cmdlet again. At
line:1 char:1 + PS C:\Users\User> + ~~~~~~~~~~~~~~~~~ + CategoryInfo :
ObjectNotFound: (C:\Users\User>:String) [Get-Process],
ProcessCommandException + FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> function Analyze-EmailContent
{ >> >> param($FilePath) >> >> >> >> if (-not (Test-Path $FilePath))
{ >> >> Write-Error "File not found: $FilePath" >> >> return >> >>
} >> >> >> >> Write-Host "=== EMAIL FORENSIC ANALYSIS ==="
-ForegroundColor Green >> >> Write-Host "File: $(Split-Path $FilePath
-Leaf)" -ForegroundColor Yellow >> >> Write-Host "Analysis Time:
$(Get-Date)" -ForegroundColor Yellow >> >> Write-Host "" >> >> >> >> try
{ >> >> # Read the HTML content >> >> $content = Get-Content $FilePath
-Raw >> >> >> >> # Extract key information using regex patterns >> >>
$title = [regex]::Match($content,
'<title>(.*?)</title>').Groups[1].Value >> >> $sender =
[regex]::Match($content, 'flongo11@gmail\.com').Value >> >> $recipients
= [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | >> >>
Select-Object -ExpandProperty Value -Unique >> >> >> >> # Extract
potential message content >> >> $bodyContent = [regex]::Match($content,
'<body[^>]*>(.*?)</body>',
[System.Text.RegularExpressions.RegexOptions]::Singleline).Groups[1].Value >> >> >> >>
# Clean HTML tags from body for readability >> >> $cleanBody =
$bodyContent -replace '<[^>]+>', ' ' -replace '\s+', ' ' -replace
'&nbsp;', ' ' >> >> >> >> # Display findings >> >> Write-Host "===
EXTRACTED INFORMATION ===" -ForegroundColor Cyan >> >> >> >> Write-Host
"`nEMAIL TITLE:" -ForegroundColor White >> >> Write-Host " $title"
-ForegroundColor Gray >> >> >> >> Write-Host "`nSENDER:"
-ForegroundColor White >> >> Write-Host " $sender" -ForegroundColor
Gray >> >> >> >> Write-Host "`nRECIPIENTS (Partial List):"
-ForegroundColor White >> >> $recipients | Select-Object -First 10 |
ForEach-Object { >> >> Write-Host " $_" -ForegroundColor Gray >> >>
} >> >> >> >> Write-Host "`nCONTENT PREVIEW:" -ForegroundColor
White >> >> Write-Host " $($cleanBody.Substring(0, [Math]::Min(500,
$cleanBody.Length)))..." -ForegroundColor Gray >> >> >> >> # Check for
keywords indicating the nature of the $keywords = @( >> >> 'corruption',
'blocking', 'government', 'evidence', >> >> 'systematic', 'urgent',
'detected', 'RCMP', 'ombudsman', >> >> 'attorney general', 'crown',
'justice' >> >> ) >> >> At line:48 char:67 + >> 'corruption',
'blocking', 'government', 'evidence', + ~ Missing expression after ','
in pipeline element. At line:49 char:28 + >> 'systematic', 'urgent',
'detected', 'RCMP', 'ombudsman ... + ~ Missing argument in parameter
list. At line:49 char:72 + ... 'systematic', 'urgent', 'detected',
'RCMP', 'ombudsman', + ~ Missing expression after ',' in pipeline
element. At line:50 char:1 + >> 'attorney general', 'crown', 'justice' +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ The output stream for this command is
already redirected. At line:50 char:34 + >> 'attorney general', 'crown',
'justice' + ~ Missing argument in parameter list. At line:14
char:12 + >> try { + ~ Missing closing '}' in statement block or type
definition. At line:1 char:49 + PS C:\Users\User> function
Analyze-EmailContent { + ~ Missing closing '}' in statement block or
type definition. At line:51 char:12 + >> ) + ~ Unexpected token ')' in
expression or statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpression PS C:\Users\User> At line:14 char:9 The AT command has
been deprecated. Please use schtasks.exe instead. Invalid command. The
AT command schedules commands and programs to run on a computer at a
specified time and date. The Schedule service must be running to use the
AT command. AT [\\computername] [ [id] [/DELETE] | /DELETE [/YES]] AT
[\\computername] time [/INTERACTIVE] [ /EVERY:date[,...] |
/NEXT:date[,...]] "command" \\computername Specifies a remote computer.
Commands are scheduled on the local computer if this parameter is
omitted. id Is an identification number assigned to a scheduled command.
/delete Cancels a scheduled command. If id is omitted, all the scheduled
commands on the computer are canceled. /yes Used with cancel all jobs
command when no further confirmation is desired. time Specifies the time
when command is to run. /interactive Allows the job to interact with the
desktop of the user who is logged on at the time the job runs.
/every:date[,...] Runs the command on each specified day(s) of the week
or month. If date is omitted, the current day of the month is assumed.
/next:date[,...] Runs the specified command on the next occurrence of
the day (for example, next Thursday). If date is omitted, the current
day of the month is assumed. "command" Is the Windows NT command, or
batch program to be run. PS C:\Users\User> + try { >> + ~ >> Missing
closing '}' in statement block or type definition. >> At line:50
char:51 >> + 'attorney general', 'crown', 'justice' >> + ~ >> The Try
statement is missing its Catch or Finally block. >> At line:1
char:31 >> + function Analyze-EmailContent { >> + ~ >> Missing closing
'}' in statement block or type definition. >> At line:51 char:9 >> +
) >> + ~ At line:1 char:2 + + try { + ~ Missing expression after unary
operator '+'. At line:1 char:7 + + try { + ~~~ Unexpected token 'try' in
expression or statement. At line:2 char:2 + + ~ + ~ Missing expression
after unary operator '+'. At line:2 char:11 + + ~ + ~ Unexpected token
'~' in expression or statement. At line:6 char:2 + + ~ + ~ Missing
expression after unary operator '+'. At line:6 char:53 + + ~ + ~
Unexpected token '~' in expression or statement. At line:9 char:2 + +
function Analyze-EmailContent { + ~ Missing expression after unary
operator '+'. At line:9 char:3 + + function Analyze-EmailContent { +
~~~~~~~~ Unexpected token 'function' in expression or statement. At
line:10 char:2 + + ~ + ~ Missing expression after unary operator '+'. At
line:10 char:33 + + ~ + ~ Unexpected token '~' in expression or
statement. Not all parse errors were reported. Correct the reported
errors and try again. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> Unexpected token ')' in
expression or statement. Unexpected : The term 'Unexpected' is not
recognized as the name of a cmdlet, function, script file, or operable
program. Check the spelling of the name, or if a path was included,
verify that the path is correct and try again. At line:1 char:1 +
Unexpected token ')' in expression or statement. + ~~~~~~~~~~ +
CategoryInfo : ObjectNotFound: (Unexpected:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> + CategoryInfo : ParserError:
(:) [], ParentContainsErrorRecordException At line:1 char:6 + +
CategoryInfo : ParserError: (:) [], ParentContainsErro ... + ~ Missing
expression after unary operator '+'. At line:1 char:7 + + CategoryInfo :
ParserError: (:) [], ParentContainsErro ... + ~~~~~~~~~~~~ Unexpected
token 'CategoryInfo' in expression or statement. + CategoryInfo :
ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingExpressionAfterOperator PS
C:\Users\User> + FullyQualifiedErrorId : MissingEndCurlyBrace At line:1
char:6 + + FullyQualifiedErrorId : MissingEndCurlyBrace + ~ Missing
expression after unary operator '+'. At line:1 char:7 + +
FullyQualifiedErrorId : MissingEndCurlyBrace + ~~~~~~~~~~~~~~~~~~~~~
Unexpected token 'FullyQualifiedErrorId' in expression or statement. +
CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingExpressionAfterOperator PS C:\Users\User>
PS C:\Users\User> PS C:\Users\User> Write-Host "`n=== KEYWORD ANALYSIS
===" -ForegroundColor Cyan Get-Process : A positional parameter cannot
be found that accepts argument 'Write-Host'. At line:1 char:1 + PS
C:\Users\User> Write-Host "`n=== KEYWORD ANALYSIS ===" -Fo ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> === KEYWORD ANALYSIS === === : The
term '===' is not recognized as the name of a cmdlet, function, script
file, or operable program. Check the spelling of the name, or if a path
was included, verify that the path is correct and try again. At line:1
char:1 + === KEYWORD ANALYSIS === + ~~~ + CategoryInfo : ObjectNotFound:
(===:String) [], CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User> foreach
($keyword in $keywords) { >> >> $count = ($content | Select-String
-Pattern $keyword -AllMatches).Matches.Count >> >> if ($count -gt 0)
{ >> >> Write-Host " $keyword : $count occurrences" -ForegroundColor
Yellow >> >> } >> >> } At line:1 char:45 + PS C:\Users\User> foreach
($keyword in $keywords) { + ~~ Unexpected token 'in' in expression or
statement. At line:1 char:44 + PS C:\Users\User> foreach ($keyword in
$keywords) { + ~ Missing closing ')' in expression. At line:1 char:57 +
PS C:\Users\User> foreach ($keyword in $keywords) { + ~ Unexpected token
')' in expression or statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
UnexpectedToken PS C:\Users\User> PS C:\Users\User> PS : Cannot find a
process with the name "C:\Users\User>". Verify the process name and call
the cmdlet again. At line:1 char:1 + PS C:\Users\User> +
~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> # File metadata PS : Cannot find a
process with the name "C:\Users\User>". Verify the process name and call
the cmdlet again. At line:1 char:1 + PS C:\Users\User> # File metadata +
~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> $fileInfo = Get-Item $FilePath
Get-Process : A positional parameter cannot be found that accepts
argument '$null'. At line:1 char:1 + PS C:\Users\User> $fileInfo =
Get-Item $FilePath +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo
: InvalidArgument: (:) [Get-Process], ParameterBindingException +
FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Get-Item : Cannot find path 'C:\Users\User\content'
because it does not exist. Get-Item : A positional parameter cannot be
found that accepts argument 'Cannot'. At line:1 char:1 + Get-Item :
Cannot find path 'C:\Users\User\content' because it does n ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Item],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetItemCommand
PS C:\Users\User> At line:1 char:21 The AT command has been deprecated.
Please use schtasks.exe instead. Invalid command. The AT command
schedules commands and programs to run on a computer at a specified time
and date. The Schedule service must be running to use the AT command. AT
[\\computername] [ [id] [/DELETE] | /DELETE [/YES]] AT [\\computername]
time [/INTERACTIVE] [ /EVERY:date[,...] | /NEXT:date[,...]] "command"
\\computername Specifies a remote computer. Commands are scheduled on
the local computer if this parameter is omitted. id Is an identification
number assigned to a scheduled command. /delete Cancels a scheduled
command. If id is omitted, all the scheduled commands on the computer
are canceled. /yes Used with cancel all jobs command when no further
confirmation is desired. time Specifies the time when command is to run.
/interactive Allows the job to interact with the desktop of the user who
is logged on at the time the job runs. /every:date[,...] Runs the
command on each specified day(s) of the week or month. If date is
omitted, the current day of the month is assumed. /next:date[,...] Runs
the specified command on the next occurrence of the day (for example,
next Thursday). If date is omitted, the current day of the month is
assumed. "command" Is the Windows NT command, or batch program to be
run. PS C:\Users\User> + $fileInfo = Get-Item $FilePath At line:1
char:1 + + $fileInfo = Get-Item $FilePath + ~~~~~~~~~~~~~~~~~~~ The
assignment expression is not valid. The input to an assignment operator
must be an object that is able to accept assignments, such as a variable
or a property. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
InvalidLeftHandSide PS C:\Users\User> + ~~~~~~~~~~~~~~~~~~ At line:1
char:2 + + ~~~~~~~~~~~~~~~~~~ + ~ Missing expression after unary
operator '+'. At line:1 char:23 + + ~~~~~~~~~~~~~~~~~~ +
~~~~~~~~~~~~~~~~~~ Unexpected token '~~~~~~~~~~~~~~~~~~' in expression
or statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + CategoryInfo :
ObjectNotFound: (C:\Users\User\content:String) [Get-Item],
ItemNotFoundException At line:1 char:6 + + CategoryInfo :
ObjectNotFound: (C:\Users\User\content: ... + ~ Missing expression after
unary operator '+'. At line:1 char:7 + + CategoryInfo : ObjectNotFound:
(C:\Users\User\content: ... + ~~~~~~~~~~~~ Unexpected token
'CategoryInfo' in expression or statement. + CategoryInfo : ParserError:
(:) [], ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + FullyQualifiedErrorId
: PathNotFound,Microsoft.PowerShell.Commands.GetItemCommand At line:1
char:6 + + FullyQualifiedErrorId :
PathNotFound,Microsoft.PowerShell.Comma ... + ~ Missing expression after
unary operator '+'. At line:1 char:7 + + FullyQualifiedErrorId :
PathNotFound,Microsoft.PowerShell.Comma ... + ~~~~~~~~~~~~~~~~~~~~~
Unexpected token 'FullyQualifiedErrorId' in expression or statement. +
CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingExpressionAfterOperator PS C:\Users\User>
PS C:\Users\User> PS C:\Users\User> Write-Host "`n=== FILE METADATA ==="
-ForegroundColor Cyan Get-Process : A positional parameter cannot be
found that accepts argument 'Write-Host'. At line:1 char:1 + PS
C:\Users\User> Write-Host "`n=== FILE METADATA ===" -Foreg ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> === FILE METADATA === === : The term
'===' is not recognized as the name of a cmdlet, function, script file,
or operable program. Check the spelling of the name, or if a path was
included, verify that the path is correct and try again. At line:1
char:1 + === FILE METADATA === + ~~~ + CategoryInfo : ObjectNotFound:
(===:String) [], CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User> Write-Host
" Size: $($fileInfo.Length) bytes" -ForegroundColor Gray Get-Process : A
positional parameter cannot be found that accepts argument 'Write-Host'.
At line:1 char:1 + PS C:\Users\User> Write-Host " Size:
$($fileInfo.Length) byt ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Size: 0 bytes Size: : The term 'Size:' is not
recognized as the name of a cmdlet, function, script file, or operable
program. Check the spelling of the name, or if a path was included,
verify that the path is correct and try again. At line:1 char:3 + Size:
0 bytes + ~~~~~ + CategoryInfo : ObjectNotFound: (Size::String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User> Write-Host
" Created: $($fileInfo.CreationTime)" -ForegroundColor Gray Get-Process
: A positional parameter cannot be found that accepts argument
'Write-Host'. At line:1 char:1 + PS C:\Users\User> Write-Host " Created:
$($fileInfo.Creation ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Created: Created: : The term 'Created:' is not
recognized as the name of a cmdlet, function, script file, or operable
program. Check the spelling of the name, or if a path was included,
verify that the path is correct and try again. At line:1 char:3 +
Created: + ~~~~~~~~ + CategoryInfo : ObjectNotFound: (Created::String)
[], CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User> Write-Host
" Modified: $($fileInfo.LastWriteTime)" -ForegroundColor Gray
Get-Process : A positional parameter cannot be found that accepts
argument 'Write-Host'. At line:1 char:1 + PS C:\Users\User> Write-Host "
Modified: $($fileInfo.LastWri ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Modified: Modified: : The term 'Modified:' is not
recognized as the name of a cmdlet, function, script file, or operable
program. Check the spelling of the name, or if a path was included,
verify that the path is correct and try again. At line:1 char:3 +
Modified: + ~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(Modified::String) [], CommandNotFoundException + FullyQualifiedErrorId
: CommandNotFoundException PS C:\Users\User> PS C:\Users\User> PS :
Cannot find a process with the name "C:\Users\User>". Verify the process
name and call the cmdlet again. At line:1 char:1 + PS C:\Users\User> +
~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> # Security considerations PS :
Cannot find a process with the name "C:\Users\User>". Verify the process
name and call the cmdlet again. At line:1 char:1 + PS C:\Users\User> #
Security considerations + ~~~~~~~~~~~~~~~~~ + CategoryInfo :
ObjectNotFound: (C:\Users\User>:String) [Get-Process],
ProcessCommandException + FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> Write-Host "`n=== SECURITY NOTES
===" -ForegroundColor Red Get-Process : A positional parameter cannot be
found that accepts argument 'Write-Host'. At line:1 char:1 + PS
C:\Users\User> Write-Host "`n=== SECURITY NOTES ===" -Fore ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> === SECURITY NOTES === === : The
term '===' is not recognized as the name of a cmdlet, function, script
file, or operable program. Check the spelling of the name, or if a path
was included, verify that the path is correct and try again. At line:1
char:1 + === SECURITY NOTES === + ~~~ + CategoryInfo : ObjectNotFound:
(===:String) [], CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User> Write-Host
" [!] This email contains serious allegations" -ForegroundColor Red
Get-Process : A positional parameter cannot be found that accepts
argument 'Write-Host'. At line:1 char:1 + PS C:\Users\User> Write-Host "
[!] This email contains serio ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> [!] This email contains serious allegations At line:1
char:4 + [!] This email contains serious allegations + ~ Missing type
name after '['. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingTypename PS C:\Users\User> PS C:\Users\User> Write-Host " [!]
Verify authenticity before taking action" -ForegroundColor Red
Get-Process : A positional parameter cannot be found that accepts
argument 'Write-Host'. At line:1 char:1 + PS C:\Users\User> Write-Host "
[!] Verify authenticity befor ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> [!] Verify authenticity before taking action At line:1
char:4 + [!] Verify authenticity before taking action + ~ Missing type
name after '['. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingTypename PS C:\Users\User> PS C:\Users\User> Write-Host " [!]
Consider legal consultation if needed" -ForegroundColor Red Get-Process
: A positional parameter cannot be found that accepts argument
'Write-Host'. At line:1 char:1 + PS C:\Users\User> Write-Host " [!]
Consider legal consultati ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> [!] Consider legal consultation if needed At line:1
char:4 + [!] Consider legal consultation if needed + ~ Missing type name
after '['. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingTypename PS C:\Users\User> PS C:\Users\User> Write-Host " [!] Do
not forward without verification" -ForegroundColor Red Get-Process : A
positional parameter cannot be found that accepts argument 'Write-Host'.
At line:1 char:1 + PS C:\Users\User> Write-Host " [!] Do not forward
without ve ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> [!] Do not forward without verification At line:1
char:4 + [!] Do not forward without verification + ~ Missing type name
after '['. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingTypename PS C:\Users\User> PS C:\Users\User> PS : Cannot find a
process with the name "C:\Users\User>". Verify the process name and call
the cmdlet again. At line:1 char:1 + PS C:\Users\User> +
~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> } catch { >> >> Write-Error "Error
analyzing file: $($_.Exception.Message)" >> >> } At line:1 char:23 + PS
C:\Users\User> } catch { + ~ Unexpected token '}' in expression or
statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
UnexpectedToken PS C:\Users\User> At line:1 char:5 The AT command has
been deprecated. Please use schtasks.exe instead. Invalid command. The
AT command schedules commands and programs to run on a computer at a
specified time and date. The Schedule service must be running to use the
AT command. AT [\\computername] [ [id] [/DELETE] | /DELETE [/YES]] AT
[\\computername] time [/INTERACTIVE] [ /EVERY:date[,...] |
/NEXT:date[,...]] "command" \\computername Specifies a remote computer.
Commands are scheduled on the local computer if this parameter is
omitted. id Is an identification number assigned to a scheduled command.
/delete Cancels a scheduled command. If id is omitted, all the scheduled
commands on the computer are canceled. /yes Used with cancel all jobs
command when no further confirmation is desired. time Specifies the time
when command is to run. /interactive Allows the job to interact with the
desktop of the user who is logged on at the time the job runs.
/every:date[,...] Runs the command on each specified day(s) of the week
or month. If date is omitted, the current day of the month is assumed.
/next:date[,...] Runs the specified command on the next occurrence of
the day (for example, next Thursday). If date is omitted, the current
day of the month is assumed. "command" Is the Windows NT command, or
batch program to be run. PS C:\Users\User> + } catch { >> + ~ >>
Unexpected token '}' in expression or statement. >> + CategoryInfo :
ParserError: (:) [], ParentContainsErrorRecordException >> +
FullyQualifiedErrorId : UnexpectedToken >> >> PS C:\Users\User> } At
line:1 char:2 + + } catch { + ~ Missing expression after unary operator
'+'. At line:1 char:7 + + } catch { + ~ Unexpected token '}' in
expression or statement. At line:2 char:2 + + ~ + ~ Missing expression
after unary operator '+'. At line:2 char:7 + + ~ + ~ Unexpected token
'~' in expression or statement. At line:4 char:6 + + CategoryInfo :
ParserError: (:) [], ParentContainsErro ... + ~ Missing expression after
unary operator '+'. At line:4 char:7 + + CategoryInfo : ParserError: (:)
[], ParentContainsErro ... + ~~~~~~~~~~~~ Unexpected token
'CategoryInfo' in expression or statement. At line:5 char:6 + +
FullyQualifiedErrorId : UnexpectedToken + ~ Missing expression after
unary operator '+'. At line:5 char:7 + + FullyQualifiedErrorId :
UnexpectedToken + ~~~~~~~~~~~~~~~~~~~~~ Unexpected token
'FullyQualifiedErrorId' in expression or statement. + CategoryInfo :
ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingExpressionAfterOperator PS C:\Users\User>
At line:1 char:1 The AT command has been deprecated. Please use
schtasks.exe instead. Invalid command. The AT command schedules commands
and programs to run on a computer at a specified time and date. The
Schedule service must be running to use the AT command. AT
[\\computername] [ [id] [/DELETE] | /DELETE [/YES]] AT [\\computername]
time [/INTERACTIVE] [ /EVERY:date[,...] | /NEXT:date[,...]] "command"
\\computername Specifies a remote computer. Commands are scheduled on
the local computer if this parameter is omitted. id Is an identification
number assigned to a scheduled command. /delete Cancels a scheduled
command. If id is omitted, all the scheduled commands on the computer
are canceled. /yes Used with cancel all jobs command when no further
confirmation is desired. time Specifies the time when command is to run.
/interactive Allows the job to interact with the desktop of the user who
is logged on at the time the job runs. /every:date[,...] Runs the
command on each specified day(s) of the week or month. If date is
omitted, the current day of the month is assumed. /next:date[,...] Runs
the specified command on the next occurrence of the day (for example,
next Thursday). If date is omitted, the current day of the month is
assumed. "command" Is the Windows NT command, or batch program to be
run. PS C:\Users\User> + } At line:1 char:2 + + } + ~ Missing expression
after unary operator '+'. At line:1 char:3 + + } + ~ Unexpected token
'}' in expression or statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + ~ At line:1
char:2 + + ~ + ~ Missing expression after unary operator '+'. At line:1
char:3 + + ~ + ~ Unexpected token '~' in expression or statement. +
CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingExpressionAfterOperator PS C:\Users\User>
Unexpected token '}' in expression or statement. Unexpected : The term
'Unexpected' is not recognized as the name of a cmdlet, function, script
file, or operable program. Check the spelling of the name, or if a path
was included, verify that the path is correct and try again. At line:1
char:1 + Unexpected token '}' in expression or statement. + ~~~~~~~~~~ +
CategoryInfo : ObjectNotFound: (Unexpected:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> + CategoryInfo : ParserError:
(:) [], ParentContainsErrorRecordException At line:1 char:6 + +
CategoryInfo : ParserError: (:) [], ParentContainsErro ... + ~ Missing
expression after unary operator '+'. At line:1 char:7 + + CategoryInfo :
ParserError: (:) [], ParentContainsErro ... + ~~~~~~~~~~~~ Unexpected
token 'CategoryInfo' in expression or statement. + CategoryInfo :
ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingExpressionAfterOperator PS
C:\Users\User> + FullyQualifiedErrorId : UnexpectedToken At line:1
char:6 + + FullyQualifiedErrorId : UnexpectedToken + ~ Missing
expression after unary operator '+'. At line:1 char:7 + +
FullyQualifiedErrorId : UnexpectedToken + ~~~~~~~~~~~~~~~~~~~~~
Unexpected token 'FullyQualifiedErrorId' in expression or statement. +
CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingExpressionAfterOperator PS C:\Users\User>
PS C:\Users\User> PS C:\Users\User> PS : Cannot find a process with the
name "C:\Users\User>". Verify the process name and call the cmdlet
again. At line:1 char:1 + PS C:\Users\User> + ~~~~~~~~~~~~~~~~~ +
CategoryInfo : ObjectNotFound: (C:\Users\User>:String) [Get-Process],
ProcessCommandException + FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> function Export-Findings { >> >>
param($FilePath, $OutputPath = "EmailAnalysis_$(Get-Date -Format
'yyyyMMdd_HHmmss').txt") >> >> >> >> $analysis = Analyze-EmailContent
-FilePath $FilePath >> >> $analysis | Out-File -FilePath $OutputPath
-Encoding UTF8 >> >> Write-Host "`nAnalysis exported to: $OutputPath"
-ForegroundColor Green >> >> } Get-Process : A positional parameter
cannot be found that accepts argument 'function'. At line:1 char:1 + PS
C:\Users\User> function Export-Findings { +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo :
InvalidArgument: (:) [Get-Process], ParameterBindingException +
FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> PS : Cannot find a process with the
name "C:\Users\User>". Verify the process name and call the cmdlet
again. At line:1 char:1 + PS C:\Users\User> + ~~~~~~~~~~~~~~~~~ +
CategoryInfo : ObjectNotFound: (C:\Users\User>:String) [Get-Process],
ProcessCommandException + FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> # Main execution PS : Cannot find a
process with the name "C:\Users\User>". Verify the process name and call
the cmdlet again. At line:1 char:1 + PS C:\Users\User> # Main
execution + ~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> if ($FilePath) { >> >>
Analyze-EmailContent -FilePath $FilePath >> >> >> >> # Ask if user wants
to export results >> >> $export = Read-Host "`nExport analysis to file?
(y/n)" >> >> if ($export -eq 'y' -or $export -eq 'yes') { >> >>
Export-Findings -FilePath $FilePath >> >> } >> >> } else { >> >>
Write-Host "Usage: .\Analyze-EmailEvidence.ps1 -FilePath
'path\to\email.html'" -ForegroundColor Yellow >> >> } Get-Process : A
positional parameter cannot be found that accepts argument 'if'. At
line:1 char:1 + PS C:\Users\User> if ($FilePath) { +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidArgument: (:)
[Get-Process], ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Analyze-EmailContent : The term 'Analyze-EmailContent'
is not recognized as the name of a cmdlet, function, script
Analyze-EmailContent : The term 'Analyze-EmailContent' is not recognized
as the name of a cmdlet, function, script file, or operable program.
Check the spelling of the name, or if a path was included, verify that
the path is correct and try again. At line:1 char:1 +
Analyze-EmailContent : The term 'Analyze-EmailContent' is not recogni
... + ~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(Analyze-EmailContent:String) [], CommandNotFoundException +
FullyQualifiedErrorId : CommandNotFoundException PS C:\Users\User> file,
or operable program. Check the spelling of the name, or if a path was
included, verify that the path is correct At line:1 char:5 + file, or
operable program. Check the spelling of the name, or if a pa ... + ~
Missing argument in parameter list. + CategoryInfo : ParserError: (:)
[], ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingArgument PS C:\Users\User> and try again. and : The term 'and' is
not recognized as the name of a cmdlet, function, script file, or
operable program. Check the spelling of the name, or if a path was
included, verify that the path is correct and try again. At line:1
char:1 + and try again. + ~~~ + CategoryInfo : ObjectNotFound:
(and:String) [], CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> At line:2 char:5 The AT
command has been deprecated. Please use schtasks.exe instead. Invalid
command. The AT command schedules commands and programs to run on a
computer at a specified time and date. The Schedule service must be
running to use the AT command. AT [\\computername] [ [id] [/DELETE] |
/DELETE [/YES]] AT [\\computername] time [/INTERACTIVE] [
/EVERY:date[,...] | /NEXT:date[,...]] "command" \\computername Specifies
a remote computer. Commands are scheduled on the local computer if this
parameter is omitted. id Is an identification number assigned to a
scheduled command. /delete Cancels a scheduled command. If id is
omitted, all the scheduled commands on the computer are canceled. /yes
Used with cancel all jobs command when no further confirmation is
desired. time Specifies the time when command is to run. /interactive
Allows the job to interact with the desktop of the user who is logged on
at the time the job runs. /every:date[,...] Runs the command on each
specified day(s) of the week or month. If date is omitted, the current
day of the month is assumed. /next:date[,...] Runs the specified command
on the next occurrence of the day (for example, next Thursday). If date
is omitted, the current day of the month is assumed. "command" Is the
Windows NT command, or batch program to be run. PS C:\Users\User> +
Analyze-EmailContent -FilePath $FilePath At line:1 char:2 + +
Analyze-EmailContent -FilePath $FilePath + ~ Missing expression after
unary operator '+'. At line:1 char:7 + + Analyze-EmailContent -FilePath
$FilePath + ~~~~~~~~~~~~~~~~~~~~ Unexpected token 'Analyze-EmailContent'
in expression or statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + ~~~~~~~~~~~~~~~~~~~~
At line:1 char:2 + + ~~~~~~~~~~~~~~~~~~~~ + ~ Missing expression after
unary operator '+'. At line:1 char:7 + + ~~~~~~~~~~~~~~~~~~~~ +
~~~~~~~~~~~~~~~~~~~~ Unexpected token '~~~~~~~~~~~~~~~~~~~~' in
expression or statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + CategoryInfo :
ObjectNotFound: (Analyze-EmailContent:String) [],
CommandNotFoundException At line:1 char:6 + + CategoryInfo :
ObjectNotFound: (Analyze-EmailContent:S ... + ~ Missing expression after
unary operator '+'. At line:1 char:7 + + CategoryInfo : ObjectNotFound:
(Analyze-EmailContent:S ... + ~~~~~~~~~~~~ Unexpected token
'CategoryInfo' in expression or statement. + CategoryInfo : ParserError:
(:) [], ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + FullyQualifiedErrorId
: CommandNotFoundException At line:1 char:6 + + FullyQualifiedErrorId :
CommandNotFoundException + ~ Missing expression after unary operator
'+'. At line:1 char:7 + + FullyQualifiedErrorId :
CommandNotFoundException + ~~~~~~~~~~~~~~~~~~~~~ Unexpected token
'FullyQualifiedErrorId' in expression or statement. + CategoryInfo :
ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingExpressionAfterOperator PS C:\Users\User>
PS C:\Users\User> PS C:\Users\User> Export analysis to file? (y/n): #
Quick file info y/n : The term 'y/n' is not recognized as the name of a
cmdlet, function, script file, or operable program. Check the spelling
of the name, or if a path was included, verify that the path is correct
and try again. At line:1 char:27 + Export analysis to file? (y/n): #
Quick file info + ~~~ + CategoryInfo : ObjectNotFound: (y/n:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User>
Get-ChildItem "URGENT - Government Email Blocking Detected*.html"
| >> >> Select-Object Name, Length, CreationTime, LastWriteTime >> : The
term '>>' is not recognized as the name of a cmdlet, function, script
file, or operable program. Check the spelling of the name, or if a path
was included, verify that the path is correct and try again. At line:2
char:1 + >> Select-Object Name, Length, CreationTime, LastWriteTime +
~~ + CategoryInfo : ObjectNotFound: (>>:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User> PS : Cannot
find a process with the name "C:\Users\User>". Verify the process name
and call the cmdlet again. At line:1 char:1 + PS C:\Users\User> +
~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> # Check for specific agencies
mentioned PS : Cannot find a process with the name "C:\Users\User>".
Verify the process name and call the cmdlet again. At line:1 char:1 + PS
C:\Users\User> # Check for specific agencies mentioned +
~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> Select-String -Path "*.html"
-Pattern "rcmp|ombudsman|attorney\.general|crown\.windsor"
-CaseSensitive:$false Get-Process : A positional parameter cannot be
found that accepts argument 'Select-String'. At line:1 char:1 + PS
C:\Users\User> Select-String -Path "*.html" -Pattern "rcmp|ombudsm ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> PS : Cannot find a process with the
name "C:\Users\User>". Verify the process name and call the cmdlet
again. At line:1 char:1 + PS C:\Users\User> + ~~~~~~~~~~~~~~~~~ +
CategoryInfo : ObjectNotFound: (C:\Users\User>:String) [Get-Process],
ProcessCommandException + FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> # Extract all email addresses from
the file PS : Cannot find a process with the name "C:\Users\User>".
Verify the process name and call the cmdlet again. At line:1 char:1 + PS
C:\Users\User> # Extract all email addresses from the file +
~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> $content = Get-Content "URGENT -
Government Email Blocking Detected*.html" -Raw Get-Process : A
positional parameter cannot be found that accepts argument '$null'. At
line:1 char:1 + PS C:\Users\User> $content = Get-Content "URGENT -
Government Email B ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Get-Content : A parameter cannot be found that matches
parameter name 'Raw'. Get-Content : A positional parameter cannot be
found that accepts argument 'A'. At line:1 char:1 + Get-Content : A
parameter cannot be found that matches parameter name ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Content],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetContentCommand
PS C:\Users\User> At line:1 char:76 The AT command has been deprecated.
Please use schtasks.exe instead. Invalid command. The AT command
schedules commands and programs to run on a computer at a specified time
and date. The Schedule service must be running to use the AT command. AT
[\\computername] [ [id] [/DELETE] | /DELETE [/YES]] AT [\\computername]
time [/INTERACTIVE] [ /EVERY:date[,...] | /NEXT:date[,...]] "command"
\\computername Specifies a remote computer. Commands are scheduled on
the local computer if this parameter is omitted. id Is an identification
number assigned to a scheduled command. /delete Cancels a scheduled
command. If id is omitted, all the scheduled commands on the computer
are canceled. /yes Used with cancel all jobs command when no further
confirmation is desired. time Specifies the time when command is to run.
/interactive Allows the job to interact with the desktop of the user who
is logged on at the time the job runs. /every:date[,...] Runs the
command on each specified day(s) of the week or month. If date is
omitted, the current day of the month is assumed. /next:date[,...] Runs
the specified command on the next occurrence of the day (for example,
next Thursday). If date is omitted, the current day of the month is
assumed. "command" Is the Windows NT command, or batch program to be
run. PS C:\Users\User> + ... Get-Content "URGENT - Government Email
Blocking Detected*.html" -Raw At line:1 char:2 + + ... Get-Content
"URGENT - Government Email Blocking Detected*.html ... + ~ Missing
expression after unary operator '+'. At line:1 char:5 + + ...
Get-Content "URGENT - Government Email Blocking Detected*.html ... + ~
You must provide a value expression following the '..' operator. At
line:1 char:5 + + ... Get-Content "URGENT - Government Email Blocking
Detected*.html ... + ~ Unexpected token '.' in expression or
statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + ~~~~ At line:1
char:2 + + ... + ~ Missing expression after unary operator '+'. At
line:1 char:72 + ... ~~~~ + ~~~~ Unexpected token '~~~~' in expression
or statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + CategoryInfo :
InvalidArgument: (:) [Get-Content], ParameterBindingException At line:1
char:6 + + CategoryInfo : InvalidArgument: (:) [Get-Content], Par ... +
~ Missing expression after unary operator '+'. At line:1 char:7 + +
CategoryInfo : InvalidArgument: (:) [Get-Content], Par ... +
~~~~~~~~~~~~ Unexpected token 'CategoryInfo' in expression or
statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + FullyQualifiedErrorId
: NamedParameterNotFound,Microsoft.PowerShell.Commands.GetContentCommand
At line:1 char:6 + + FullyQualifiedErrorId :
NamedParameterNotFound,Microsoft.PowerS ... + ~ Missing expression after
unary operator '+'. At line:1 char:7 + + FullyQualifiedErrorId :
NamedParameterNotFound,Microsoft.PowerS ... + ~~~~~~~~~~~~~~~~~~~~~
Unexpected token 'FullyQualifiedErrorId' in expression or statement. +
CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingExpressionAfterOperator PS C:\Users\User>
PS C:\Users\User> PS C:\Users\User> [regex]::Matches($content,
'[\w\.-]+@[\w\.-]+\.\w+') | >> >> Select-Object -ExpandProperty Value
-Unique | >> >> Sort-Object >> : The term '>>' is not recognized as the
name of a cmdlet, function, script file, or operable program. Check the
spelling of the name, or if a path was included, verify that the path is
correct and try again. At line:2 char:1 + >> Select-Object
-ExpandProperty Value -Unique | + ~~ + CategoryInfo : ObjectNotFound:
(>>:String) [], CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User> PS : Cannot
find a process with the name "C:\Users\User>". Verify the process name
and call the cmdlet again. At line:1 char:1 + PS C:\Users\User> +
~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> # Check file size and content length
PS : Cannot find a process with the name "C:\Users\User>". Verify the
process name and call the cmdlet again. At line:1 char:1 + PS
C:\Users\User> # Check file size and content length +
~~~~~~~~~~~~~~~~~ + CategoryInfo : ObjectNotFound:
(C:\Users\User>:String) [Get-Process], ProcessCommandException +
FullyQualifiedErrorId :
NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> $file = Get-Item "URGENT -
Government Email Blocking Detected*.html" Get-Process : A positional
parameter cannot be found that accepts argument '$null'. At line:1
char:1 + PS C:\Users\User> $file = Get-Item "URGENT - Government Email
Blockin ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> PS C:\Users\User> $content = Get-Content
$file.FullName -Raw Get-Process : A positional parameter cannot be found
that accepts argument '$null'. At line:1 char:1 + PS C:\Users\User>
$content = Get-Content $file.FullName -Raw +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Get-Content : Cannot bind argument to parameter 'Path'
because it is null. Get-Content : A positional parameter cannot be found
that accepts argument 'Cannot'. At line:1 char:1 + Get-Content : Cannot
bind argument to parameter 'Path' because it is ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Content],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetContentCommand
PS C:\Users\User> At line:1 char:24 The AT command has been deprecated.
Please use schtasks.exe instead. Invalid command. The AT command
schedules commands and programs to run on a computer at a specified time
and date. The Schedule service must be running to use the AT command. AT
[\\computername] [ [id] [/DELETE] | /DELETE [/YES]] AT [\\computername]
time [/INTERACTIVE] [ /EVERY:date[,...] | /NEXT:date[,...]] "command"
\\computername Specifies a remote computer. Commands are scheduled on
the local computer if this parameter is omitted. id Is an identification
number assigned to a scheduled command. /delete Cancels a scheduled
command. If id is omitted, all the scheduled commands on the computer
are canceled. /yes Used with cancel all jobs command when no further
confirmation is desired. time Specifies the time when command is to run.
/interactive Allows the job to interact with the desktop of the user who
is logged on at the time the job runs. /every:date[,...] Runs the
command on each specified day(s) of the week or month. If date is
omitted, the current day of the month is assumed. /next:date[,...] Runs
the specified command on the next occurrence of the day (for example,
next Thursday). If date is omitted, the current day of the month is
assumed. "command" Is the Windows NT command, or batch program to be
run. PS C:\Users\User> + $content = Get-Content $file.FullName -Raw At
line:1 char:1 + + $content = Get-Content $file.FullName -Raw +
~~~~~~~~~~ The assignment expression is not valid. The input to an
assignment operator must be an object that is able to accept
assignments, such as a variable or a property. + CategoryInfo :
ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : InvalidLeftHandSide PS C:\Users\User> +
~~~~~~~~~~~~~~ At line:1 char:2 + + ~~~~~~~~~~~~~~ + ~ Missing
expression after unary operator '+'. At line:1 char:26 + +
~~~~~~~~~~~~~~ + ~~~~~~~~~~~~~~ Unexpected token '~~~~~~~~~~~~~~' in
expression or statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + CategoryInfo :
InvalidData: (:) [Get-Content], ParameterBindingValidationException At
line:1 char:6 + + CategoryInfo : InvalidData: (:) [Get-Content], Paramet
... + ~ Missing expression after unary operator '+'. At line:1
char:7 + + CategoryInfo : InvalidData: (:) [Get-Content], Paramet ... +
~~~~~~~~~~~~ Unexpected token 'CategoryInfo' in expression or
statement. + CategoryInfo : ParserError: (:) [],
ParentContainsErrorRecordException + FullyQualifiedErrorId :
MissingExpressionAfterOperator PS C:\Users\User> + FullyQualifiedErrorId
:
ParameterArgumentValidationErrorNullNotAllowed,Microsoft.PowerShell.Commands.GetContentC
At line:1 char:6 + + FullyQualifiedErrorId :
ParameterArgumentValidationErrorNullNot ... + ~ Missing expression after
unary operator '+'. At line:1 char:7 + + FullyQualifiedErrorId :
ParameterArgumentValidationErrorNullNot ... + ~~~~~~~~~~~~~~~~~~~~~
Unexpected token 'FullyQualifiedErrorId' in expression or statement. +
CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException +
FullyQualifiedErrorId : MissingExpressionAfterOperator PS C:\Users\User>
ommand ommand : The term 'ommand' is not recognized as the name of a
cmdlet, function, script file, or operable program. Check the spelling
of the name, or if a path was included, verify that the path is correct
and try again. At line:1 char:4 + ommand + ~~~~~~ + CategoryInfo :
ObjectNotFound: (ommand:String) [], CommandNotFoundException +
FullyQualifiedErrorId : CommandNotFoundException PS C:\Users\User> PS
C:\Users\User> PS C:\Users\User> Write-Host "File size: $($file.Length)
bytes" Get-Process : A positional parameter cannot be found that accepts
argument 'Write-Host'. At line:1 char:1 + PS C:\Users\User> Write-Host
"File size: $($file.Length) bytes" +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> File size: 0 bytes File : The term 'File' is not
recognized as the name of a cmdlet, function, script file, or operable
program. Check the spelling of the name, or if a path was included,
verify that the path is correct and try again. At line:1 char:1 + File
size: 0 bytes + ~~~~ + CategoryInfo : ObjectNotFound: (File:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User> Write-Host
"Content length: $($content.Length) characters" Get-Process : A
positional parameter cannot be found that accepts argument 'Write-Host'.
At line:1 char:1 + PS C:\Users\User> Write-Host "Content length:
$($content.Length) char ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Content length: 0 characters Get-Content : A
positional parameter cannot be found that accepts argument '0'. At
line:1 char:1 + Content length: 0 characters +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidArgument: (:)
[Get-Content], ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetContentCommand
PS C:\Users\User> PS C:\Users\User> Write-Host "Lines of code:
$(($content -split "`n").Count)" Get-Process : A positional parameter
cannot be found that accepts argument 'Write-Host'. At line:1 char:1 +
PS C:\Users\User> Write-Host "Lines of code: $(($content -split "`n")
... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> Lines of code: 1 Lines : The term 'Lines' is not
recognized as the name of a cmdlet, function, script file, or operable
program. Check the spelling of the name, or if a path was included,
verify that the path is correct and try again. At line:1 char:1 + Lines
of code: 1 + ~~~~~ + CategoryInfo : ObjectNotFound: (Lines:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> PS C:\Users\User>
.\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" Get-Process : A positional parameter
cannot be found that accepts argument '.\Analyze-EmailEvidence.ps1'. At
line:1 char:1 + PS C:\Users\User> .\Analyze-EmailEvidence.ps1 -FilePath
"URGENT - Gov ... +
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : InvalidArgument: (:) [Get-Process],
ParameterBindingException + FullyQualifiedErrorId :
PositionalParameterNotFound,Microsoft.PowerShell.Commands.GetProcessCommand
PS C:\Users\User> .\Analyze-EmailEvidence.ps1 : The term
'.\Analyze-EmailEvidence.ps1' is not recognized as the name of a
cmdlet, >> function, script file, or operable program. Check the
spelling of the name, or if a path was included, verify that the
.\Analyze-EmailEvidence.ps1 : The term '.\Analyze-EmailEvidence.ps1' is
not recognized as the name of a cmdlet, function, script file, or
operable program. Check the spelling of the name, or if a path was
included, verify that the path is correct and try again. At line:1
char:1 + .\Analyze-EmailEvidence.ps1 : The term
'.\Analyze-EmailEvidence.ps1' ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~ +
CategoryInfo : ObjectNotFound: (.\Analyze-EmailEvidence.ps1:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> path is correct and try
again. path : The term 'path' is not recognized as the name of a cmdlet,
function, script file, or operable program. Check the spelling of the
name, or if a path was included, verify that the path is correct and try
again. At line:1 char:1 + path is correct and try again. + ~~~~ +
CategoryInfo : ObjectNotFound: (path:String) [],
CommandNotFoundException + FullyQualifiedErrorId :
CommandNotFoundException PS C:\Users\User> At line:1 char:1 The AT
command has been deprecated. Please use schtasks.exe instead. Invalid
command. The AT command schedules commands and programs to run on a
computer at a specified time and date. The Schedule service must be
running to use the AT command. AT [\\computername] [ [id] [/DELETE] |
/DELETE [/YES]] AT [\\computername] time [/INTERACTIVE] [
/EVERY:date[,...] | /NEXT:date[,...]] "command" \\computername Specifies
a remote computer. Commands are scheduled on the local computer if this
parameter is omitted. id Is an identification number assigned to a
scheduled command. /delete Cancels a scheduled command. If id is
omitted, all the scheduled commands on the computer are canceled. /yes
Used with cancel all jobs command when no further confirmation is
desired. time Specifies the time when command is to run. /interactive
Allows the job to interact with the desktop of the user who is logged on
at the time the job runs. /every:date[,...] Runs the command on each
specified day(s) of the week or month. If date is omitted, the current
day of the month is assumed. /next:date[,...] Runs the specified command
on the next occurrence of the day (for example, next Thursday). If date
is omitted, the current day of the month is assumed. "command" Is the
Windows NT command, or batch program to be run. PS C:\Users\User> +
.\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email Bloc
... >> + ~~~~~~~~~~~~~~~~~~~~~~~~~~~ >> + CategoryInfo : ObjectNotFound:
(.\Analyze-EmailEvidence.ps1:String) [], CommandNotFoundException >> +
FullyQualifiedErrorId : CommandNotFoundException >> # Change to the
directory where you saved the script >> cd
"C:\path\to\script\directory" >> # List files to see if the script is
there >> Get-ChildItem *.ps1 >> # Allow running local scripts (run as
Administrator if needed) >> Set-ExecutionPolicy -ExecutionPolicy
RemoteSigned -Scope CurrentUser >> # Use dot-slash before the script
name >> .\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" >> # Quick analysis without the script
file >> $filePath = "URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> $content = Get-Content $filePath -Raw >> >> Write-Host
"=== QUICK ANALYSIS ===" -ForegroundColor Green >> Write-Host "File:
$filePath" -ForegroundColor Yellow >> Write-Host "Size: $((Get-Item
$filePath).Length) bytes" -ForegroundColor Yellow >> >> # Extract email
addresses >> $emails = [regex]::Matches($content,
'[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value
-Unique >> Write-Host "`nRecipients found: $($emails.Count)"
-ForegroundColor Cyan >> $emails | ForEach-Object { Write-Host " $_"
-ForegroundColor Gray } >> >> # Check for key phrases >> $phrases =
@('corruption', 'blocking', 'government', 'evidence', 'urgent',
'RCMP') >> Write-Host "`nKey phrases found:" -ForegroundColor Cyan >>
foreach ($phrase in $phrases) { >> if ($content -match $phrase) { >>
Write-Host " $phrase" -ForegroundColor Yellow >> } >> } >> Get-ChildItem
"*Government Email Blocking*" -Recurse >> $path =
"FULL_PATH_TO_YOUR_FILE.html" >> .\Analyze-EmailEvidence.ps1 -FilePath
$path >> >> Get-Location >> Get-ChildItem -Filter "*.ps1" >>
Set-Location "C:\path\to\script\directory" >> Get-ExecutionPolicy >>
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser >>
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser >>
.\Analyze-EmailEvidence.ps1 -FilePath "URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" >> $filePath = "URGENT - Government
Email Blocking Detected - Systematic Corruption Evidence - Francesco
Longo - flongo11@gmail.com - Gmail.html" >> $content = Get-Content
$filePath -Raw >> >> Write-Host "=== QUICK ANALYSIS ==="
-ForegroundColor Green >> Write-Host "File: $filePath" -ForegroundColor
Yellow >> Write-Host "Size: $((Get-Item $filePath).Length) bytes"
-ForegroundColor Yellow >> >> # Extract email addresses >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "`nRecipients found:
$($emails.Count)" -ForegroundColor Cyan >> $emails | ForEach-Object {
Write-Host " $_" -ForegroundColor Gray } >> >> # Check for key
phrases >> $phrases = @('corruption', 'blocking', 'government',
'evidence', 'urgent', 'RCMP') >> Write-Host "`nKey phrases found:"
-ForegroundColor Cyan >> foreach ($phrase in $phrases) { >> if ($content
-match $phrase) { >> Write-Host " $phrase" -ForegroundColor Yellow >>
} >> } >> Get-ChildItem -Path "C:\" -Filter "*Government Email
Blocking*" -Recurse -ErrorAction SilentlyContinue >> >> $filePath =
"C:\Users\User\Downloads\URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> Test-Path "URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> Get-ChildItem -Path "C:\Users\User" -Filter "*Government
Email Blocking*" -Recurse >> # Simple Email Analysis Script >>
param($FilePath) >> >> if (-not (Test-Path $FilePath)) { >> Write-Host
"File not found: $FilePath" -ForegroundColor Red >> return >> } >> >>
$content = Get-Content $FilePath -Raw >> $file = Get-Item
$FilePath >> >> Write-Host "=== EMAIL ANALYSIS ===" -ForegroundColor
Green >> Write-Host "File: $($file.Name)" -ForegroundColor Yellow >>
Write-Host "Size: $($file.Length) bytes" -ForegroundColor Yellow >>
Write-Host "Location: $($file.FullName)" -ForegroundColor Yellow >> >> #
Extract email addresses >> $emails = [regex]::Matches($content,
'[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value
-Unique >> Write-Host "`nRecipients found: $($emails.Count)"
-ForegroundColor Cyan >> $emails | ForEach-Object { Write-Host " $_"
-ForegroundColor Gray } >> >> # Check for key phrases >> $phrases =
@('corruption', 'blocking', 'government', 'evidence', 'urgent', 'RCMP',
'ombudsman') >> Write-Host "`nKey phrases found:" -ForegroundColor
Cyan >> foreach ($phrase in $phrases) { >> $count = ($content |
Select-String -Pattern $phrase -AllMatches).Matches.Count >> if ($count
-gt 0) { >> Write-Host " $phrase : $count occurrences" -ForegroundColor
Yellow >> } >> }# If you saved it in your User folder: >>
.\email_check.ps1 -FilePath "URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" >> $filePath = "URGENT - Government
Email Blocking Detected - Systematic Corruption Evidence - Francesco
Longo - flongo11@gmail.com - Gmail.html"; if (Test-Path $filePath) {
$content = Get-Content $filePath -Raw; $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique; Write-Host "Found $($emails.Count) email
addresses:" -ForegroundColor Green; $emails } else { Write-Host "File
not found!" -ForegroundColor Red }Test-Path "URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" >> $content = Get-Content "URGENT -
Government Email Blocking Detected - Systematic Corruption Evidence -
Francesco Longo - flongo11@gmail.com - Gmail.html" -Raw >>
$content.Length >>

[]

[]

[]

Thought for 94 seconds

[]

We are seeing a lot of errors because the user is trying to copy and
paste a large block of code that includes the PowerShell prompt and
comments, which is not working. The user is also trying to run the
script without having the script file created.

Let's break this down step by step:

1.  The user needs to create a PowerShell script file.

2.  Then, they need to run that script.

However, the user is having trouble because they are pasting the entire
code block, including the PS C:\Users\User> prompts and the comments,
which is causing errors.

Let me provide a clean, step-by-step guide:

Step 1: Create the script file.

-   Open Notepad.

-   Copy the script code (without any PS C:\Users\User> prompts) and
    save it as Analyze-EmailEvidence.ps1.

Step 2: Run the script in PowerShell.

Alternatively, let me provide a one-liner that the user can run without
creating a script file.

But given the complexity of the script, let's try to simplify.

Since the user is having so much trouble, let's use the one-liner
approach I provided earlier:

powershell

[]

Copy

[]

Download

    $filePath = "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; if (Test-Path $filePath) { $content = Get-Content $filePath -Raw; $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique; Write-Host "Found $($emails.Count) email addresses:" -ForegroundColor Green; $emails } else { Write-Host "File not found!" -ForegroundColor Red }

[][]

However, the user tried that and it didn't work because the file might
not be in the current directory.

Let's check if the file exists:

powershell

[]

Copy

[]

Download

    Test-Path "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

If it returns False, then the file is not in the current directory.

The user can search for the file:

powershell

[]

Copy

[]

Download

    Get-ChildItem -Path "C:\" -Filter "*Government Email Blocking*" -Recurse -ErrorAction SilentlyContinue

[][]

But note: searching the entire C: drive might take a long time.
Alternatively, the user can check their Downloads folder or Desktop.

Let's try to guide the user to find the file and then run the analysis.

Since the user is in C:\Users\User, let's check common locations:

powershell

[]

Copy

[]

Download

    $paths = @("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop", "$env:USERPROFILE\Documents")
    foreach ($path in $paths) {
        Get-ChildItem -Path $path -Filter "*Government Email Blocking*" -ErrorAction SilentlyContinue
    }

[][]

If the file is found, note the full path and then run the analysis.

Given the complexity, let me provide a simplified script that the user
can run step by step.

Alternatively, let's try to run the one-liner with the full path.

Example:

powershell

[]

Copy

[]

Download

    $filePath = "C:\Users\User\Downloads\URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

Then run the one-liner with that full path.

Since the user is having trouble with the script, let's do it manually:

Step 1: Check if the file exists.
Step 2: If it exists, read the content and extract the emails.

Let's do:

powershell

[]

Copy

[]

Download

    $filePath = "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"
    if (Test-Path $filePath) {
        $content = Get-Content $filePath -Raw
        $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique
        Write-Host "Found $($emails.Count) email addresses:" -ForegroundColor Green
        $emails
    } else {
        Write-Host "File not found in the current directory. Please provide the full path." -ForegroundColor Red
    }

[][]

But note: the user might be using an older version of PowerShell that
doesn't support -Raw in Get-Content. Let's check the PowerShell version.

Alternatively, we can use Get-Content | Out-String to get the raw
content.

Let me adjust:

powershell

[]

Copy

[]

Download

    $filePath = "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"
    if (Test-Path $filePath) {
        $content = Get-Content $filePath | Out-String
        $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique
        Write-Host "Found $($emails.Count) email addresses:" -ForegroundColor Green
        $emails
    } else {
        Write-Host "File not found in the current directory. Please provide the full path." -ForegroundColor Red
    }

[][]

Now, let's try to run this in the user's PowerShell.

But note: the user is getting errors because they are copying the entire
block including the PS C:\Users\User> prompt.

Let me remind the user:

-   Open a new PowerShell window.

-   Copy and paste the code below (without the PS C:\Users\User> prompt)
    and press Enter.

powershell

[]

Copy

[]

Download

    $filePath = "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"
    if (Test-Path $filePath) {
        $content = Get-Content $filePath | Out-String
        $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique
        Write-Host "Found $($emails.Count) email addresses:" -ForegroundColor Green
        $emails
    } else {
        Write-Host "File not found in the current directory. Please provide the full path." -ForegroundColor Red
    }

[][]

If the file is not found, the user must provide the full path.

Let's try to get the full path by searching:

powershell

[]

Copy

[]

Download

    Get-ChildItem -Path "$env:USERPROFILE" -Filter "*Government Email Blocking*" -Recurse -ErrorAction SilentlyContinue

[][]

This will search the user's profile directory.

If the file is found, set $filePath to the full path.

Example:

powershell

[]

Copy

[]

Download

    $filePath = "C:\Users\User\Downloads\URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

Then run the analysis again.

Given the user's difficulty, let's try to do everything in one step:

powershell

[]

Copy

[]

Download

    $file = Get-ChildItem -Path "$env:USERPROFILE" -Filter "*Government Email Blocking*" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
    if ($file) {
        $content = Get-Content $file.FullName | Out-String
        $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique
        Write-Host "Found $($emails.Count) email addresses:" -ForegroundColor Green
        $emails
    } else {
        Write-Host "File not found." -ForegroundColor Red
    }

[][]

This will search for the file and use the first one found.

Let's hope this works.

However, note that the user might have multiple files. We are using
Select-Object -First 1 to take the first one.

Let's run this and see.

But note: the user might have the file in a different drive. We are only
searching the user profile.

If the user wants to search the entire C: drive, they can change the
path to "C:", but that might take a long time.

Let's try to run the above code and see if it finds the file.

If it doesn't, the user must locate the file manually and provide the
full path.

Alternatively, the user can use the file dialog to find the file and
then drag and drop the file into the PowerShell window to get the full
path.

Let's try one more time with the one-liner that searches the user
profile.

I think we are overwhelming the user with multiple attempts. Let's stick
to one approach.

Step 1: Search for the file in the user profile.

Step 2: If found, analyze it.

Step 3: If not found, ask the user to provide the full path.

We can do:

powershell

[]

Copy

[]

Download

    $file = Get-ChildItem -Path "$env:USERPROFILE" -Filter "*Government Email Blocking*" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
    if (-not $file) {
        Write-Host "File not found in your user profile. Please provide the full path." -ForegroundColor Red
        exit
    }
    $content = Get-Content $file.FullName | Out-String
    $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique
    Write-Host "Found $($emails.Count) email addresses:" -ForegroundColor Green
    $emails

[][]

This will either show the emails or exit if the file is not found.

Let's hope this works.

If the user is still having trouble, they might need to run PowerShell
as administrator to search the entire drive, but I don't think that's
necessary.

Let's try to run the above code.

Note: The user must copy and paste the code without the
PS C:\Users\User> prompt.

I hope this helps.

I can see you're having major issues with copying and pasting PowerShell
code. Let's start completely fresh with a simple approach.

Step 1: Close ALL PowerShell Windows

-   Close every PowerShell window you have open

-   Open ONE NEW PowerShell window

Step 2: Check if your file exists

In your NEW PowerShell window, type this EXACT command and press Enter:

powershell

[]

Copy

[]

Download

    Test-Path "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

What does it say? True or False?

Step 3: If it says "True", run this simple command:

powershell

[]

Copy

[]

Download

    $file = Get-Item "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"
    Write-Host "File size: $($file.Length) bytes"

[][]

Step 4: If Step 3 works, run this to extract email addresses:

powershell

[]

Copy

[]

Download

    $content = Get-Content "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html" | Out-String
    $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique
    Write-Host "Found $($emails.Count) email addresses:"
    $emails

[][]

If Step 2 says "False", let's find your file:

powershell

[]

Copy

[]

Download

    Get-ChildItem -Path "C:\Users\User" -Filter "*Government Email Blocking*" -Recurse

[][]

IMPORTANT RULES:

1.  Only copy the command text (don't copy PS C:\Users\User>)

2.  Paste ONE command at a time

3.  Press Enter after each command

4.  Wait for it to finish before pasting the next

Let me know what happens with Step 2

Just tell me:

-   Does Test-Path return True or False?

-   If False, what does the Get-ChildItem command show?

Don't copy any script files yet. Let's get the basics working first.

Copy and paste this EXACTLY into your NEW PowerShell window:

powershell

[]

Copy

[]

Download

    Test-Path "URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

What is the result?

[]

[]

[]

[]

[]

Copyright (C) Microsoft Corporation. All rights reserved. Try the new
cross-platform PowerShell https://aka.ms/pscore6 PS C:\Users\User>
$filePath = "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html"; if (Test-Path $filePath) { $content = Get-Content $filePath
-Raw; $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') |
Select-Object -ExpandProperty Value -Unique; Write-Host "Found
$($emails.Count) email addresses:" -ForegroundColor Green; $emails }
else { Write-Host "File not found!" -ForegroundColor Red } File not
found! PS C:\Users\User> Test-Path "URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" False PS C:\Users\User> Get-ChildItem
-Path "C:\" -Filter "*Government Email Blocking*" -Recurse -ErrorAction
SilentlyContinue Directory: C:\Users\User\Downloads Mode LastWriteTime
Length Name ---- ------------- ------ ---- d----- 2025-10-16 12:24 AM
URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail_files -a----
2025-10-16 12:24 AM 4347903 URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html PS C:\Users\User> $paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") PS C:\Users\User> foreach ($path in
$paths) { >> Get-ChildItem -Path $path -Filter "*Government Email
Blocking*" -ErrorAction SilentlyContinue >> }$paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") Directory: C:\Users\User\Downloads Mode
LastWriteTime Length Name ---- ------------- ------ ---- d-----
2025-10-16 12:24 AM URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail_files -a---- 2025-10-16 12:24 AM 4347903 URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html PS C:\Users\User> foreach ($path in
$paths) { >> Get-ChildItem -Path $path -Filter "*Government Email
Blocking*" -ErrorAction SilentlyContinue >> $paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") >> foreach ($path in $paths) { >>
Get-ChildItem -Path $path -Filter "*Government Email Blocking*"
-ErrorAction SilentlyContinue >> }$paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") >> foreach ($path in $paths) { >>
Get-ChildItem -Path $path -Filter "*Government Email Blocking*"
-ErrorAction SilentlyContinue >> }$filePath =
"C:\Users\User\Downloads\URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> $filePath = "URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" >> if (Test-Path $filePath) { >>
$content = Get-Content $filePath -Raw >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> } >> $filePath = "URGENT -
Government Email Blocking Detected - Systematic Corruption Evidence -
Francesco Longo - flongo11@gmail.com - Gmail.html" >> if (Test-Path
$filePath) { >> $content = Get-Content $filePath -Raw >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> }$filePath = "URGENT - Government
Email Blocking Detected - Systematic Corruption Evidence - Francesco
Longo - flongo11@gmail.com - Gmail.html" >> if (Test-Path $filePath)
{ >> $content = Get-Content $filePath | Out-String >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> }$filePath = "URGENT - Government
Email Blocking Detected - Systematic Corruption Evidence - Francesco
Longo - flongo11@gmail.com - Gmail.html" >> if (Test-Path $filePath)
{ >> $content = Get-Content $filePath | Out-String >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> }Get-ChildItem -Path
"$env:USERPROFILE" -Filter "*Government Email Blocking*" -Recurse
-ErrorAction SilentlyContinue$filePath =
"C:\Users\User\Downloads\URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> $file = Get-ChildItem -Path "$env:USERPROFILE" -Filter
"*Government Email Blocking*" -Recurse -ErrorAction SilentlyContinue |
Select-Object -First 1 >> if ($file) { >> $content = Get-Content
$file.FullName | Out-String >> $emails = [regex]::Matches($content,
'[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value
-Unique >> Write-Host "Found $($emails.Count) email addresses:"
-ForegroundColor Green >> $emails >> } else { >> Write-Host "File not
found." -ForegroundColor Red >> } >> $file = Get-ChildItem -Path
"$env:USERPROFILE" -Filter "*Government Email Blocking*" -Recurse
-ErrorAction SilentlyContinue | Select-Object -First 1 >> if (-not
$file) { >> Write-Host "File not found in your user profile. Please
provide the full path." -ForegroundColor Red >> exit >> } >> $content =
Get-Content $file.FullName | Out-String >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> Test-Path
"URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"$file =
Get-Item "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> Write-Host "File size: $($file.Length) bytes"$content =
Get-Content "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"
| Out-String >> $emails = [regex]::Matches($content,
'[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value
-Unique >> Write-Host "Found $($emails.Count) email addresses:" >>
$emailsGet-ChildItem -Path "C:\Users\User" -Filter "*Government Email
Blocking*" -RecurseTest-Path "URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" >>

[]

[]

[]

Stopped

[]

We are getting a lot of errors because the user is copying and pasting
the entire code block, including the PowerShell prompts and comments.
Let's start fresh and guide the user step by step.

The user has confirmed that the file is located at:
Directory: C:\Users\User\Downloads
Mode LastWriteTime Length Name
---- ------------- ------ ----
-a---- 2025-10-16 12:24 AM 4347903 URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html

So the full path is:
C:\Users\User\Downloads\URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html

We can now use this full path to analyze the file.

Let's write a simple script that uses the full path and then run it step
by step.

However, the user is having trouble with copying and pasting. Let's
break it down into single commands.

Step 1: Set the full path to a variable.
Step 2: Check if the file exists.
Step 3: Read the content and extract email addresses.

We'll do it one command at a time.

But note: The user is in the directory C:\Users\User and the file is in
C:\Users\User\Downloads. So we can either change to that directory or
use the full path.

Let's use the full path.

We'll write a simple one-liner to extract the email addresses and then
display them.

But the user tried a one-liner and it didn't work because the file was
not found. Now we know the full path, so let's use that.

We can do:

powershell

[]

Copy

[]

Download

    $filePath = "C:\Users\User\Downloads\URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"
    $content = Get-Content $filePath -Raw
    $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique
    Write-Host "Found $($emails.Count) email addresses:" -ForegroundColor Green
    $emails

[][]

But note: The user might have an older version of PowerShell that
doesn't support -Raw parameter. If that's the case, we can use
Out-String instead.

Alternatively, we can use:

powershell

[]

Copy

[]

Download

    $content = Get-Content $filePath | Out-String

[][]

Let's try with the full path and without -Raw first.

But wait, the user already found the file and ran a command that found
the file, but then they tried to use the relative path and it didn't
work.

So, let's run the above commands one by one.

However, the user is copying and pasting multiple commands at once and
getting errors. Let's guide them to run one command at a time.

I will now provide the commands one by one.

Command 1: Set the file path

powershell

[]

Copy

[]

Download

    $filePath = "C:\Users\User\Downloads\URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"

[][]

Command 2: Check if the file exists

powershell

[]

Copy

[]

Download

    Test-Path $filePath

[][]

Command 3: Read the file and extract emails

powershell

[]

Copy

[]

Download

    $content = Get-Content $filePath | Out-String
    $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value -Unique
    Write-Host "Found $($emails.Count) email addresses:" -ForegroundColor Green
    $emails

[][]

But note: The user might have a lot of email addresses. We can also
check for key phrases.

Alternatively, we can write a script that does everything, but let's
stick to simple commands.

Given the user's difficulty, let's try to run the above three commands
one by one.

But wait, the user already ran a similar command and it worked? Let's
see:

In the user's last message, they ran:

powershell

[]

Copy

[]

Download

    $file = Get-ChildItem -Path "$env:USERPROFILE" -Filter "*Government Email Blocking*" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1

[][]

and then extracted emails and found 17 email addresses.

So the user already has the emails. But let's do it again with the full
path.

Alternatively, we can just use the file they found.

But the user wants a PowerShell script to check it. We can write a
script that does:

1.  Find the file automatically.

2.  Analyze the content.

But the user is having trouble running scripts. So let's stick to simple
commands.

Since the user already found the file and extracted the emails, maybe we
don't need to do anything else.

But if the user wants a more comprehensive analysis, we can write a
script and save it as a .ps1 file and then run it.

However, the user's execution policy might be blocking scripts. So we
can either change the execution policy or run the commands manually.

Given the complexity, let's just run the commands manually.

But the user asked for a PowerShell script. So let's write a script and
then guide the user on how to run it.

Script: Analyze-Email.ps1

powershell

[]

Copy

[]

Download

    # Analyze-Email.ps1

    # Find the file
    $file = Get-ChildItem -Path "$env:USERPROFILE" -Filter "*Government Email Blocking*" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1

    if (-not $file) {
        Write-Host "File not found." -ForegroundColor Red
        exit
    }

    Write-Host "Found file: $($file.FullName)" -ForegroundColor Green

    # Read the content
    $content = Get-Content $file.FullName -Raw

    # Extract email addresses
    $emails = [regex]::

[][]

[]

[]

[]

[]

[]

JUST WRITE THE CMD ALL IN ONE SHOT

[]

[]

[]

Thought for 123 seconds

[]

We are going to write a single PowerShell command that will analyze the
email file.
Since the user is having trouble with multi-line scripts, we'll create a
one-liner that does the following:

1.  Check if the file exists.

2.  Read the file content.

3.  Extract email addresses.

4.  Check for key phrases.

5.  Display the results.

However, note that the user tried using -Raw and it didn't work. Let's
avoid -Raw and use Out-String instead.

We'll break it down into a one-liner that can be copied and pasted
entirely.

But note: The user wants a single command. We can use a semicolon to
separate commands, but it might be long.

Alternatively, we can use a single pipeline and a script block.

However, given the user's difficulty, let's try a simple one-liner that
does:

if (Test-Path "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html") { $content = Get-Content "URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" | Out-String; $emails =
[regex]::Matches($content, '[\w.-]+@[\w.-]+.\w+') | Select-Object
-ExpandProperty Value -Unique; Write-Host "=== QUICK ANALYSIS ==="
-ForegroundColor Green; Write-Host "File: URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" -ForegroundColor Yellow; Write-Host
"Size: $((Get-Item 'URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html').Length) bytes" -ForegroundColor Yellow; Write-Host
"Recipients found: $($emails.Count)" -ForegroundColor Cyan; $emails |
ForEach-Object { Write-Host " $_" -ForegroundColor Gray }; $phrases =
@('corruption', 'blocking', 'government', 'evidence', 'urgent', 'RCMP',
'ombudsman'); Write-Host "Key phrases found:" -ForegroundColor Cyan;
foreach ($phrase in $phrases) { $count = ($content | Select-String
-Pattern $phrase -AllMatches).Matches.Count; if ($count -gt 0) {
Write-Host " $phrase : $count occurrences" -ForegroundColor Yellow } } }
else { Write-Host "File not found!" -ForegroundColor Red }

But note: This is a very long one-liner and might be prone to errors.

Alternatively, we can write a one-liner that uses the file path as a
variable to avoid repetition.

Let's try:

$p = "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html"; if (Test-Path $p) { $c = Get-Content $p | Out-String;
$emails = [regex]::Matches($c, '[\w.-]+@[\w.-]+.\w+') | Select-Object
-ExpandProperty Value -Unique; Write-Host "=== QUICK ANALYSIS ==="
-ForegroundColor Green; Write-Host "File: $p" -ForegroundColor Yellow;
Write-Host "Size: $((Get-Item $p).Length) bytes" -ForegroundColor
Yellow; Write-Host "Recipients found: $($emails.Count)" -ForegroundColor
Cyan; $emails | ForEach-Object { Write-Host " $_" -ForegroundColor Gray
}; $phrases = @('corruption', 'blocking', 'government', 'evidence',
'urgent', 'RCMP', 'ombudsman'); Write-Host "Key phrases found:"
-ForegroundColor Cyan; foreach ($phrase in $phrases) { $count = ($c |
Select-String -Pattern $phrase -AllMatches).Matches.Count; if ($count
-gt 0) { Write-Host " $phrase : $count occurrences" -ForegroundColor
Yellow } } } else { Write-Host "File not found!" -ForegroundColor Red }

However, the user may have an older version of PowerShell that doesn't
support the -Raw parameter, so we use Out-String to get the entire
content as a single string.

But note: The user's PowerShell version might be old. The above
one-liner uses basic features.

Let's write the one-liner with the file path variable to make it shorter
and avoid repetition.

But note: The user wants a single command. We can use:

$p="URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; if
(Test-Path $p) { $c=Get-Content $p|Out-String;
$emails=[regex]::Matches($c,'[\w.-]+@[\w.-]+.\w+')|Select-Object
-ExpandProperty Value -Unique; Write-Host "=== QUICK ANALYSIS ==="
-ForegroundColor Green; Write-Host "File: $p" -ForegroundColor Yellow;
Write-Host "Size: $((Get-Item $p).Length) bytes" -ForegroundColor
Yellow; Write-Host "Recipients found: $($emails.Count)" -ForegroundColor
Cyan; $emails|ForEach-Object{Write-Host " $_" -ForegroundColor Gray};
$phrases='corruption','blocking','government','evidence','urgent','RCMP','ombudsman';
Write-Host "Key phrases found:" -ForegroundColor Cyan; foreach ($phrase
in $phrases) { $count=($c|Select-String -Pattern $phrase
-AllMatches).Matches.Count; if ($count -gt 0) { Write-Host " $phrase :
$count occurrences" -ForegroundColor Yellow } } } else { Write-Host
"File not found!" -ForegroundColor Red }

However, the one-liner is very long and might be difficult to copy and
paste without errors.

Alternatively, we can break it into multiple lines for clarity, but the
user wants one shot.

Since the user is in a hurry, let's provide the one-liner and hope it
works.

But note: The user's console might have a limited buffer for pasting
long commands.

We'll provide the one-liner and also a shorter version that just
extracts emails and key phrases without the formatting.

Let me provide two options:

Option 1 (Full analysis with formatting):

$p="URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; if
(Test-Path $p) { $c=Get-Content $p|Out-String;
$emails=[regex]::Matches($c,'[\w.-]+@[\w.-]+.\w+')|Select-Object
-ExpandProperty Value -Unique; Write-Host "=== QUICK ANALYSIS ==="
-ForegroundColor Green; Write-Host "File: $p" -ForegroundColor Yellow;
Write-Host "Size: $((Get-Item $p).Length) bytes" -ForegroundColor
Yellow; Write-Host "Recipients found: $($emails.Count)" -ForegroundColor
Cyan; $emails|ForEach-Object{Write-Host " $_" -ForegroundColor Gray};
$phrases='corruption','blocking','government','evidence','urgent','RCMP','ombudsman';
Write-Host "Key phrases found:" -ForegroundColor Cyan; foreach ($phrase
in $phrases) { $count=($c|Select-String -Pattern $phrase
-AllMatches).Matches.Count; if ($count -gt 0) { Write-Host " $phrase :
$count occurrences" -ForegroundColor Yellow } } } else { Write-Host
"File not found!" -ForegroundColor Red }

Option 2 (Just the facts, minimal output):

$p="URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; if
(Test-Path $p) { $c=Get-Content $p|Out-String;
$emails=[regex]::Matches($c,'[\w.-]+@[\w.-]+.\w+')|Select-Object
-ExpandProperty Value -Unique; "Recipients: $($emails.Count)"; $emails;
"Key phrases:";
$phrases='corruption','blocking','government','evidence','urgent','RCMP','ombudsman';
foreach ($phrase in $phrases) { $count=($c|Select-String -Pattern
$phrase -AllMatches).Matches.Count; if ($count -gt 0) { "$phrase :
$count" } } } else { "File not found!" }

Option 2 is shorter and might be easier to paste.

Given the user's frustration, let's go with Option 2.

But note: The user might want to see the output in a more readable way.

However, the user said "JUST WRITE THE CMD ALL IN ONE SHOT", so we'll
provide Option 2 as a one-liner.

Let me write Option 2 without the variable for phrases to make it even
shorter:

$p="URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; if
(Test-Path $p) { $c=Get-Content $p|Out-String;
$emails=[regex]::Matches($c,'[\w.-]+@[\w.-]+.\w+')|Select-Object
-ExpandProperty Value -Unique; "Recipients: $($emails.Count)"; $emails;
"Key phrases:";
('corruption','blocking','government','evidence','urgent','RCMP','ombudsman')
| ForEach-Object { $count=($c|Select-String -Pattern $_
-AllMatches).Matches.Count; if ($count -gt 0) { "$_ : $count" } } } else
{ "File not found!" }

This is a bit shorter and uses a pipeline for phrases.

Let's test this in our environment to make sure it works.

However, note that the user's file might be large and
Get-Content | Out-String might be slow, but it's a one-time analysis.

We'll provide this one-liner.

But note: The user might have a different file name. We are hardcoding
the file name.

If the user has a different file name, they can replace the string in
the variable.

We'll write the one-liner with the hardcoded file name.

Final one-liner (Option 2):

$p="URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; if
(Test-Path $p) { $c=Get-Content $p|Out-String;
$emails=[regex]::Matches($c,'[\w.-]+@[\w.-]+.\w+')|Select-Object
-ExpandProperty Value -Unique; "Recipients: $($emails.Count)"; $emails;
"Key phrases:";
('corruption','blocking','government','evidence','urgent','RCMP','ombudsman')
| ForEach-Object { $count=($c|Select-String -Pattern $_
-AllMatches).Matches.Count; if ($count -gt 0) { "$_ : $count" } } } else
{ "File not found!" }

We'll output this as the one-shot command.

However, if the user is using an older PowerShell (version 2.0) then
Select-String might not have -AllMatches and the script might fail.

But the user is using a version that has -Raw (which they tried) so it's
at least version 3.0.

Let's assume the user has PowerShell 3.0 or above.

We'll provide the one-liner.

If the user wants to run it, they can copy and paste the entire line.

Let me write it without any line breaks.

Here's the complete PowerShell command all in one line:

powershell

[]

Copy

[]

Download

    $p="URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; if (Test-Path $p) { $c=Get-Content $p; Write-Host "FILE FOUND - Size: $((Get-Item $p).Length) bytes"; $e=[regex]::Matches($c,'[\w\.-]+@[\w\.-]+\.\w+')|Select-Object -ExpandProperty Value -Unique; Write-Host "EMAILS FOUND: $($e.Count)"; $e } else { Write-Host "FILE NOT FOUND" -ForegroundColor Red }

[][]

Copy and paste this EXACT line into PowerShell and press Enter.

If you want the version with keyword analysis too:

powershell

[]

Copy

[]

Download

    $p="URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; if (Test-Path $p) { $c=Get-Content $p; Write-Host "FILE FOUND - Size: $((Get-Item $p).Length) bytes"; $e=[regex]::Matches($c,'[\w\.-]+@[\w\.-]+\.\w+')|Select-Object -ExpandProperty Value -Unique; Write-Host "EMAILS: $($e.Count)"; $e; Write-Host "KEYWORDS:"; @('corruption','blocking','government','evidence','urgent','RCMP','ombudsman')|ForEach-Object { if ($c -match $_) { Write-Host "  $_ - FOUND" -ForegroundColor Yellow } } } else { Write-Host "FILE NOT FOUND" -ForegroundColor Red }

[][]

Just copy ONE of these commands and paste into PowerShell.

[]

[]

[]

[]

[]

Copyright (C) Microsoft Corporation. All rights reserved. Try the new
cross-platform PowerShell https://aka.ms/pscore6 PS C:\Users\User>
$filePath = "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html"; if (Test-Path $filePath) { $content = Get-Content $filePath
-Raw; $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') |
Select-Object -ExpandProperty Value -Unique; Write-Host "Found
$($emails.Count) email addresses:" -ForegroundColor Green; $emails }
else { Write-Host "File not found!" -ForegroundColor Red } File not
found! PS C:\Users\User> Test-Path "URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" False PS C:\Users\User> Get-ChildItem
-Path "C:\" -Filter "*Government Email Blocking*" -Recurse -ErrorAction
SilentlyContinue Directory: C:\Users\User\Downloads Mode LastWriteTime
Length Name ---- ------------- ------ ---- d----- 2025-10-16 12:24 AM
URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail_files -a----
2025-10-16 12:24 AM 4347903 URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html PS C:\Users\User> $paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") PS C:\Users\User> foreach ($path in
$paths) { >> Get-ChildItem -Path $path -Filter "*Government Email
Blocking*" -ErrorAction SilentlyContinue >> }$paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") Directory: C:\Users\User\Downloads Mode
LastWriteTime Length Name ---- ------------- ------ ---- d-----
2025-10-16 12:24 AM URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail_files -a---- 2025-10-16 12:24 AM 4347903 URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html PS C:\Users\User> foreach ($path in
$paths) { >> Get-ChildItem -Path $path -Filter "*Government Email
Blocking*" -ErrorAction SilentlyContinue >> $paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") >> foreach ($path in $paths) { >>
Get-ChildItem -Path $path -Filter "*Government Email Blocking*"
-ErrorAction SilentlyContinue >> }$paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") >> foreach ($path in $paths) { >>
Get-ChildItem -Path $path -Filter "*Government Email Blocking*"
-ErrorAction SilentlyContinue >> }$filePath =
"C:\Users\User\Downloads\URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> $filePath = "URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" >> if (Test-Path $filePath) { >>
$content = Get-Content $filePath -Raw >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> } >> $filePath = "URGENT -
Government Email Blocking Detected - Systematic Corruption Evidence -
Francesco Longo - flongo11@gmail.com - Gmail.html" >> if (Test-Path
$filePath) { >> $content = Get-Content $filePath -Raw >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> }$filePath = "URGENT - Government
Email Blocking Detected - Systematic Corruption Evidence - Francesco
Longo - flongo11@gmail.com - Gmail.html" >> if (Test-Path $filePath)
{ >> $content = Get-Content $filePath | Out-String >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> }$filePath = "URGENT - Government
Email Blocking Detected - Systematic Corruption Evidence - Francesco
Longo - flongo11@gmail.com - Gmail.html" >> if (Test-Path $filePath)
{ >> $content = Get-Content $filePath | Out-String >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> }Get-ChildItem -Path
"$env:USERPROFILE" -Filter "*Government Email Blocking*" -Recurse
-ErrorAction SilentlyContinue$filePath =
"C:\Users\User\Downloads\URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> $file = Get-ChildItem -Path "$env:USERPROFILE" -Filter
"*Government Email Blocking*" -Recurse -ErrorAction SilentlyContinue |
Select-Object -First 1 >> if ($file) { >> $content = Get-Content
$file.FullName | Out-String >> $emails = [regex]::Matches($content,
'[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value
-Unique >> Write-Host "Found $($emails.Count) email addresses:"
-ForegroundColor Green >> $emails >> } else { >> Write-Host "File not
found." -ForegroundColor Red >> } >> $file = Get-ChildItem -Path
"$env:USERPROFILE" -Filter "*Government Email Blocking*" -Recurse
-ErrorAction SilentlyContinue | Select-Object -First 1 >> if (-not
$file) { >> Write-Host "File not found in your user profile. Please
provide the full path." -ForegroundColor Red >> exit >> } >> $content =
Get-Content $file.FullName | Out-String >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> Test-Path
"URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"$file =
Get-Item "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> Write-Host "File size: $($file.Length) bytes"$content =
Get-Content "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"
| Out-String >> $emails = [regex]::Matches($content,
'[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value
-Unique >> Write-Host "Found $($emails.Count) email addresses:" >>
$emailsGet-ChildItem -Path "C:\Users\User" -Filter "*Government Email
Blocking*" -RecurseTest-Path "URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" >> $p="URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html"; if (Test-Path $p) { $c=Get-Content $p;
Write-Host "FILE FOUND - Size: $((Get-Item $p).Length) bytes";
$e=[regex]::Matches($c,'[\w\.-]+@[\w\.-]+\.\w+')|Select-Object
-ExpandProperty Value -Unique; Write-Host "EMAILS FOUND: $($e.Count)";
$e } else { Write-Host "FILE NOT FOUND" -ForegroundColor Red } >>

[]

[]

[]

Thought for 7 seconds

[]

We are getting "File not found!" because the file is not in the current
directory.
The file is in the Downloads folder, as shown by the Get-ChildItem
command.
Let's use the full path to the file.

We can see from the Get-ChildItem output that the file is at:
C:\Users\User\Downloads\URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html

We can also see that there is a folder with the same name (with _files)
but we are interested in the .html file.

Let's run the analysis with the full path.

Perfect! The file is in your Downloads folder. Here's the ONE-LINE
COMMAND to analyze it:

powershell

[]

Copy

[]

Download

    $p="C:\Users\User\Downloads\URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; $c=Get-Content $p; Write-Host "=== EMAIL ANALYSIS ===" -ForegroundColor Green; Write-Host "File: $(Split-Path $p -Leaf)" -ForegroundColor Yellow; Write-Host "Size: $((Get-Item $p).Length) bytes" -ForegroundColor Yellow; $e=[regex]::Matches($c,'[\w\.-]+@[\w\.-]+\.\w+')|Select-Object -ExpandProperty Value -Unique; Write-Host "`nRECIPIENTS: $($e.Count)" -ForegroundColor Cyan; $e; Write-Host "`nKEYWORDS:" -ForegroundColor Cyan; @('corruption','blocking','government','evidence','urgent','RCMP','ombudsman','attorney','crown','justice')|ForEach-Object { $m=($c|Select-String $_ -AllMatches).Matches.Count; if ($m -gt 0) { Write-Host "  $_ : $m occurrences" -ForegroundColor Yellow } }; Write-Host "`n=== SECURITY NOTE ===" -ForegroundColor Red; Write-Host "Verify authenticity before taking action" -ForegroundColor Red

[][]

Copy and paste this EXACT line into PowerShell and press Enter.

This will show you:

-   File information

-   All email addresses found

-   Keyword occurrences

-   Security warning

The file exists at:
C:\Users\User\Downloads\URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html

[]

[]

[]

[]

[]

Copyright (C) Microsoft Corporation. All rights reserved. Try the new
cross-platform PowerShell https://aka.ms/pscore6 PS C:\Users\User>
$filePath = "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html"; if (Test-Path $filePath) { $content = Get-Content $filePath
-Raw; $emails = [regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') |
Select-Object -ExpandProperty Value -Unique; Write-Host "Found
$($emails.Count) email addresses:" -ForegroundColor Green; $emails }
else { Write-Host "File not found!" -ForegroundColor Red } File not
found! PS C:\Users\User> Test-Path "URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" False PS C:\Users\User> Get-ChildItem
-Path "C:\" -Filter "*Government Email Blocking*" -Recurse -ErrorAction
SilentlyContinue Directory: C:\Users\User\Downloads Mode LastWriteTime
Length Name ---- ------------- ------ ---- d----- 2025-10-16 12:24 AM
URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail_files -a----
2025-10-16 12:24 AM 4347903 URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html PS C:\Users\User> $paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") PS C:\Users\User> foreach ($path in
$paths) { >> Get-ChildItem -Path $path -Filter "*Government Email
Blocking*" -ErrorAction SilentlyContinue >> }$paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") Directory: C:\Users\User\Downloads Mode
LastWriteTime Length Name ---- ------------- ------ ---- d-----
2025-10-16 12:24 AM URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail_files -a---- 2025-10-16 12:24 AM 4347903 URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html PS C:\Users\User> foreach ($path in
$paths) { >> Get-ChildItem -Path $path -Filter "*Government Email
Blocking*" -ErrorAction SilentlyContinue >> $paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") >> foreach ($path in $paths) { >>
Get-ChildItem -Path $path -Filter "*Government Email Blocking*"
-ErrorAction SilentlyContinue >> }$paths =
@("$env:USERPROFILE\Downloads", "$env:USERPROFILE\Desktop",
"$env:USERPROFILE\Documents") >> foreach ($path in $paths) { >>
Get-ChildItem -Path $path -Filter "*Government Email Blocking*"
-ErrorAction SilentlyContinue >> }$filePath =
"C:\Users\User\Downloads\URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> $filePath = "URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" >> if (Test-Path $filePath) { >>
$content = Get-Content $filePath -Raw >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> } >> $filePath = "URGENT -
Government Email Blocking Detected - Systematic Corruption Evidence -
Francesco Longo - flongo11@gmail.com - Gmail.html" >> if (Test-Path
$filePath) { >> $content = Get-Content $filePath -Raw >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> }$filePath = "URGENT - Government
Email Blocking Detected - Systematic Corruption Evidence - Francesco
Longo - flongo11@gmail.com - Gmail.html" >> if (Test-Path $filePath)
{ >> $content = Get-Content $filePath | Out-String >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> }$filePath = "URGENT - Government
Email Blocking Detected - Systematic Corruption Evidence - Francesco
Longo - flongo11@gmail.com - Gmail.html" >> if (Test-Path $filePath)
{ >> $content = Get-Content $filePath | Out-String >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> } else { >>
Write-Host "File not found in the current directory. Please provide the
full path." -ForegroundColor Red >> }Get-ChildItem -Path
"$env:USERPROFILE" -Filter "*Government Email Blocking*" -Recurse
-ErrorAction SilentlyContinue$filePath =
"C:\Users\User\Downloads\URGENT - Government Email Blocking Detected -
Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> $file = Get-ChildItem -Path "$env:USERPROFILE" -Filter
"*Government Email Blocking*" -Recurse -ErrorAction SilentlyContinue |
Select-Object -First 1 >> if ($file) { >> $content = Get-Content
$file.FullName | Out-String >> $emails = [regex]::Matches($content,
'[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value
-Unique >> Write-Host "Found $($emails.Count) email addresses:"
-ForegroundColor Green >> $emails >> } else { >> Write-Host "File not
found." -ForegroundColor Red >> } >> $file = Get-ChildItem -Path
"$env:USERPROFILE" -Filter "*Government Email Blocking*" -Recurse
-ErrorAction SilentlyContinue | Select-Object -First 1 >> if (-not
$file) { >> Write-Host "File not found in your user profile. Please
provide the full path." -ForegroundColor Red >> exit >> } >> $content =
Get-Content $file.FullName | Out-String >> $emails =
[regex]::Matches($content, '[\w\.-]+@[\w\.-]+\.\w+') | Select-Object
-ExpandProperty Value -Unique >> Write-Host "Found $($emails.Count)
email addresses:" -ForegroundColor Green >> $emails >> Test-Path
"URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"$file =
Get-Item "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence - Francesco Longo - flongo11@gmail.com -
Gmail.html" >> Write-Host "File size: $($file.Length) bytes"$content =
Get-Content "URGENT - Government Email Blocking Detected - Systematic
Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"
| Out-String >> $emails = [regex]::Matches($content,
'[\w\.-]+@[\w\.-]+\.\w+') | Select-Object -ExpandProperty Value
-Unique >> Write-Host "Found $($emails.Count) email addresses:" >>
$emailsGet-ChildItem -Path "C:\Users\User" -Filter "*Government Email
Blocking*" -RecurseTest-Path "URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html" >> $p="URGENT - Government Email
Blocking Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html"; if (Test-Path $p) { $c=Get-Content $p;
Write-Host "FILE FOUND - Size: $((Get-Item $p).Length) bytes";
$e=[regex]::Matches($c,'[\w\.-]+@[\w\.-]+\.\w+')|Select-Object
-ExpandProperty Value -Unique; Write-Host "EMAILS FOUND: $($e.Count)";
$e } else { Write-Host "FILE NOT FOUND" -ForegroundColor Red } >>
$p="URGENT - Government Email Blocking Detected - Systematic Corruption
Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; if
(Test-Path $p) { $c=Get-Content $p; Write-Host "FILE FOUND - Size:
$((Get-Item $p).Length) bytes";
$e=[regex]::Matches($c,'[\w\.-]+@[\w\.-]+\.\w+')|Select-Object
-ExpandProperty Value -Unique; Write-Host "EMAILS: $($e.Count)"; $e;
Write-Host "KEYWORDS:";
@('corruption','blocking','government','evidence','urgent','RCMP','ombudsman')|ForEach-Object
{ if ($c -match $_) { Write-Host " $_ - FOUND" -ForegroundColor Yellow }
} } else { Write-Host "FILE NOT FOUND" -ForegroundColor Red } >>
$p="C:\Users\User\Downloads\URGENT - Government Email Blocking
Detected - Systematic Corruption Evidence - Francesco Longo -
flongo11@gmail.com - Gmail.html"; $c=Get-Content $p; Write-Host "===
EMAIL ANALYSIS ===" -ForegroundColor Green; Write-Host "File:
$(Split-Path $p -Leaf)" -ForegroundColor Yellow; Write-Host "Size:
$((Get-Item $p).Length) bytes" -ForegroundColor Yellow;
$e=[regex]::Matches($c,'[\w\.-]+@[\w\.-]+\.\w+')|Select-Object
-ExpandProperty Value -Unique; Write-Host "`nRECIPIENTS: $($e.Count)"
-ForegroundColor Cyan; $e; Write-Host "`nKEYWORDS:" -ForegroundColor
Cyan;
@('corruption','blocking','government','evidence','urgent','RCMP','ombudsman','attorney','crown','justice')|ForEach-Object
{ $m=($c|Select-String $_ -AllMatches).Matches.Count; if ($m -gt 0) {
Write-Host " $_ : $m occurrences" -ForegroundColor Yellow } };
Write-Host "`n=== SECURITY NOTE ===" -ForegroundColor Red; Write-Host
"Verify authenticity before taking action" -ForegroundColor Red >>

[]

[]

[]

Thought for 3 seconds

[]

We are getting "File not found!" because the file is not in the current
directory.
The file is in the Downloads folder, so we need to use the full path.
Let me provide a one-liner that uses the full path to the file in the
Downloads folder.

Perfect! Now I can see the file exists in your Downloads folder. Here's
the FINAL ONE-LINE COMMAND with the correct full path:

powershell

[]

Copy

[]

Download

    $p="C:\Users\User\Downloads\URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html"; if (Test-Path $p) { $c=Get-Content $p; Write-Host "=== EMAIL ANALYSIS ===" -ForegroundColor Green; Write-Host "File: $(Split-Path $p -Leaf)" -ForegroundColor Yellow; Write-Host "Size: $((Get-Item $p).Length) bytes" -ForegroundColor Yellow; $e=[regex]::Matches($c,'[\w\.-]+@[\w\.-]+\.\w+')|Select-Object -ExpandProperty Value -Unique; Write-Host "`nRECIPIENTS: $($e.Count)" -ForegroundColor Cyan; $e; Write-Host "`nKEYWORDS:" -ForegroundColor Cyan; @('corruption','blocking','government','evidence','urgent','RCMP','ombudsman','attorney','crown','justice')|ForEach-Object { $m=($c|Select-String $_ -AllMatches).Matches.Count; if ($m -gt 0) { Write-Host "  $_ : $m occurrences" -ForegroundColor Yellow } }; Write-Host "`n=== SECURITY NOTE ===" -ForegroundColor Red; Write-Host "Verify authenticity before taking action" -ForegroundColor Red } else { Write-Host "FILE NOT FOUND" -ForegroundColor Red }

[][]

Copy and paste this EXACT line into PowerShell and press Enter.

This will analyze the file that's actually in your Downloads folder and
show you:

-   File information (name, size)

-   All email addresses found

-   Keyword frequency counts

-   Security warning

The file is located at:
C:\Users\User\Downloads\URGENT - Government Email Blocking Detected - Systematic Corruption Evidence - Francesco Longo - flongo11@gmail.com - Gmail.html

Just copy that one line above and paste it into PowerShell.

[]

[]

[]

[]

[]

[]

DeepThink

[]

Search

[]

[]

AI-generated, for reference only

One more step before you proceed...

[]

Ask about this image

------------------------------------------------------------------------

[]

[]

Hide on this site

Hide always

------------------------------------------------------------------------

You can re-enable it in Settings

[]

Ask about this image

------------------------------------------------------------------------

[]

[]

Hide on this site

Hide always

------------------------------------------------------------------------

You can re-enable it in Settings

[]

[]

[]

[]
